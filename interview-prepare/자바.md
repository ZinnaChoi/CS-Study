### JVM < JRE < JDK

| 구분     | JVM (Java Virtual Machine)                                                                      | JRE (Java Runtime Environment)                                                            | JDK (Java Development Kit)                                                                             |
| -------- | ----------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| **정의** | 자바 가상 머신으로, 자바 컴파일러에 의해 생성된 클래스 파일을 기계어로 변환해 주는 역할을 수행. | 자바 실행 환경으로, 자바로 만들어진 프로그램을 실행시키기 위한 라이브러리들과 JVM을 포함. | 자바 개발 키트로, 자바 개발에 필요한 도구와 라이브러리를 포함. JRE도 포함하여 자바 프로그램 실행 가능. |
| **구성** | - 클래스 로더<br>- 실행 엔진<br>- 가비지 콜렉터<br>- 런타임 데이터 영역                         | - 실행에 필요한 라이브러리들<br>- JVM<br>- 사용자 인터페이스 도구 등                      | - JRE<br>- 개발에 필요한 도구(javac, java debugger 등)<br>- 라이브러리                                 |
| **용도** | - 바이트 코드를 기계어로 변환하여 실행<br>- OS 독립적 실행 환경 제공                            | - 자바 애플리케이션 실행 환경 제공                                                        | - 자바 애플리케이션 개발 및 실행                                                                       |

---

### JVM 메모리 구조

<p align="center">   <img src="img/JVM.png"> </p>

| 구분                          | 설명                                                                                                                                                                                                                                                               |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **클래스 로더**               | JVM 내로 클래스를 로드하는 시스템. 자바 바이트코드(.class 파일)를 JVM으로 로딩하고, 링크를 통해 배치하는 과정을 담당.                                                                                                                                              |
| **실행 엔진**                 | 바이트 코드를 실제로 실행할 수 있는 기계어로 변환하는 역할을 수행. 인터프리터와 JIT 컴파일러를 포함하여, 바이트 코드를 효율적으로 실행.                                                                                                                            |
| **가비지 컬렉터**             | 더 이상 사용되지 않는 메모리 자원을 자동으로 회수. Heap 영역에서 사용하지 않는 객체를 탐지하고, 메모리를 해제하여 메모리 누수를 방지.                                                                                                                              |
| **런타임 데이터 영역**        | JVM이 프로그램 실행을 위해 사용하는 메모리 공간. 다음 영역으로 구성됨:                                                                                                                                                                                             |
| **Method Area (Static Area)** | - 클래스 수준의 정보(클래스 이름, 부모 클래스 이름, 메소드, 변수 등) 저장.<br>- `static`과 `final` 변수도 이 영역에 저장됨.<br>- JVM 내에 하나만 존재하며 모든 스레드가 공유.                                                                                      |
| **Heap Area**                 | - 모든 클래스 인스턴스와 배열이 동적으로 할당되는 공간.<br>- 가비지 컬렉션이 이루어지는 주 영역으로, 더 이상 참조되지 않는 객체를 자동으로 제거.<br>- JVM 내에 하나만 존재하며 모든 스레드가 공유.                                                                 |
| **Stack Area**                | - Java 메소드 호출 시 생성되는 지역변수, 파라미터, 리턴 값 등을 저장하는 영역.<br>- 메소드가 호출될 때마다 각 스레드 별로 스택 프레임이 생성.<br>- 동적 객체는 여기서 참조만 관리되며, 실제 객체는 Heap 영역에 저장됨.<br>- 각 스레드가 자신만의 스택 영역을 가짐. |

---

### Java 컴파일 과정

#### 컴파일 타임

- 1. 소스 코드 작성 : .java로 소스 코드가 생성된다
- 2. 컴파일: 자바 컴파일러(javac)는 소스 코드 파일을 입력으로 받아 바이트 코드(.class)로 변환.

#### 런 타임

- 3. JVM 로드: 컴파일된 바이트 코드는 JVM 클래스 로더에 의해 JVM 메모리로 로드
- 4. 바이트 코드 실행: JVM의 실행 엔진이 바이트 코드를 기계어로 변환 후 변환된 기계어 코드를 런타임 데이터 영역에 배치
- 5. 실행: 변환된 기계어 코드가 실행되어 프로그램의 로직이 수행

---

### 컴파일러 vs 인터프리터

| 기준             | 컴파일러                                | 인터프리터                             |
| ---------------- | --------------------------------------- | -------------------------------------- |
| 정의             | 프로그램 코드를 기계어로 변환한 뒤 실행 | 프로그램을 한 줄 씩 읽으면서 바로 실행 |
| 개발 디버깅 속도 | 느리다                                  | 빠르다                                 |
| 실행 속도        | 빠르다                                  | 느리다                                 |
| 예시             | C, C++, Java                            | Python, Ruby, Javascript               |

---

### 객체 지향 프로그래밍(OOP)이란?

| 구분                | 설명                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **정의**            | - **현실 세계 모델링**: 현실 세계의 대상과 그 기능을 객체로 추상화하여 프로그램에 표현<br>- **명령의 주체-객체**: 명령을 수행하는 주체가 객체이며, 이 객체들이 서로 상호작용하며 프로그램이 실행                                                                                                                                                                                                                                                                                                                                                                                |
| **객체지향의 특징** | - **추상화**: 공통된 특성을 파악하여 불필요한 정보를 제거. EX) '자동차'라는 클래스를 통해 다양한 자동차들의 공통적인 특성(속성과 행위)을 모델링<br>- **모듈화**: 프로그램을 독립적인 단위, 즉 모듈로 분할하여 각각의 모듈이 하나의 기능을 담당하도록 하여 코드의 재사용성과 유지보수성을 높임<br>- **상속**: 한 클래스의 속성과 메소드를 다른 클래스가 이어받아 사용할 수 있게 하여 코드의 중복을 줄이고 재사용성을 높임.<br>- **다형성**: 같은 이름의 메소드가 클래스에 따라 다른 행위를 할 수 있게 함으로써, 하나의 메소드 호출로 다양한 실행 결과를 얻음. 코드의 유연성 증가 |

---

### 객체지향 5대 원칙 SOLID

| **원칙**                   | **설명**                                                                                          |
| -------------------------- | ------------------------------------------------------------------------------------------------- |
| SRP (단일 책임 원칙)       | 한 클래스는 하나의 책임만 가져야 함                                                               |
| OCP (개방-폐쇄 원칙)       | 클래스는 확장에는 열려 있으나 변경에는 닫혀 있어야 함                                             |
| LSP (리스코프 치환 원칙)   | 하위 클래스는 상위 클래스의 기능을 이용할 수 있어야 하며, 상위 클래스의 인스턴스 대체 가능해야 함 |
| ISP (인터페이스 분리 원칙) | 클라이언트는 사용하지 않는 메서드에 의존하면 안 됨, 필요한 인터페이스만 제공해야 함               |
| DIP (의존관계 역전 원칙)   | 구현 클래스가 아닌 인터페이스에 의존해야 하며, 상위 모듈은 하위 모듈에 의존하면 안 됨             |

---

### 추상 클래스 vs 인터페이스

| -          | 추상 클래스                                                                              | 인터페이스                                                                            |
| ---------- | ---------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| **정의**   | 부분적으로 구현된 클래스로, 하나의 클래스가 단 하나만 상속받을 수 있음.                  | 모든 메서드가 추상 메서드인 클래스로, 다중 상속이 가능함.                             |
| **사용법** | `abstract` 키워드로 선언되며, `extends` 키워드로 상속 받음.                              | `interface` 키워드로 선언되며, `implements` 키워드를 통해 구현됨.                     |
| **목적**   | 객체의 추상적인 상위 개념을 표현하여 공통된 개념을 표현할 때 사용.                       | 구현 객체의 같은 동작을 보장하여, 서브 클래스에게 구현할 메서드의 원형을 미리 알려줌. |
| **특징**   | 구현된 메서드도 포함할 수 있으며, 상속받는 서브 클래스는 모든 추상 메서드를 구현해야 함. | 모든 메서드는 추상 메서드여야 하며, 클래스는 여러 인터페이스를 구현할 수 있음.        |
| **예시**   | EX) `Animal` 추상 클래스에서 `Bird` 클래스가 상속.                                       | EX) `Flyable` 인터페이스를 여러 클래스가 구현하여 `fly` 동작 수행.                    |

---

### 정적 타입 언어

- 컴파일 시 타임(자료형)을 결정.(java, C) 컴파일 시 타입을 정하기 때문에 실행 속도가 빠르고 타입 에러로 인한 문제점을 초기에 발견 가능

### 동적 타입 언어

- 런타임 과정에서 타입을 결정(python) 유연성이 높지만 타입 에러 발생 가능

### 오버로딩과 오버라이딩

- 오버로딩은 매개변수나 타입을 다르게 하여 같은 이름의 메서드를 여러 개 정의하는 것
- 오버라이딩은 상속 관게의 두 클래스가 있을 때 자식 클래스가 부모 클래스의 메서드를 재정의하는 것

#### 캡슐화와 은닉화의 차이

- 캡슐화는 객체의 데이터와 메서드를 하나로 묶는 것인 반면 은닉화는 객체의 일부 세부 사항을 외부로부터 숨기는 것(객체의 데이터를 보호하기 위함, 접근 제어자 사용)

### Java의 특징

- JVM을 사용하기에 운영체제와 독립적이다
- 객체 지향 언어이기에 캡슐화 , 상속, 추상화, 다형성 등의 특징을 가진다
- 컴파일 시 데이터 타입이 결정되는 정적 타입 언어이다

### 클래스/객체/인스턴스

- 클래스: 객체를 생성하기 위한 템플릿
- 객체 : 클래스에 정의된 속성과 메소드를 실제로 가지고 있는 실체
- 인스턴스: 클래스로부터 생성된 구체적인 객체. 클래스 타입으로 메모리에 할당된 구체적인 객체. 객체가 더 큰 개념

### 접근 제어자

> 객체 지향 프로그래밍 이란 객체들 간의 상호작용을 코드로 표현하는 것인데, 이 때 객체들 간의 관계에 따라서 접근할 수 있는 것과 아닌 것, 권한을 구분할 필요가 존재

- 클래스, 인터페이스, 변수, 함수 등의 접근을 제어하는 지시어로 외부 객체의 무분별한 접근으로부터 데이터를 보호할 수 있다 (데이터의 무결성: 정확하고 일관된 데이터)
- public : 모든 패키지, 모든 class
- protected: 같은 패키지, 모든 클래스 (다른 패키지일 경우 자식 클래스의 접근은 허용)
- default: 같은 패키지
- private: 같은 class

### DAO BO DTO VO

- DAO : data access object

  - DB의 데이터를 조회, 조작하는 객체. DB와 직접적으로 상호작용하는 로직을 비지니스 로직과 분리할 수 있음 (repository, mapper)

- BO : business object

  - 비지니스 로직을 처리하는 객체. (service)

- DTO: data transfer object

  - 객체 간의 데이터 교환이 이뤄질 수 있도록 하는 객체
  - 일반 적으로 특별한 로직을 가지고 있지 않고 Getter와 Setter만을 가짐 (Controller)

- VO (Value Obejct)
  - 데이터의 값 자체에 초점. read only 특성을 가짐. 데이터만을 저장하는 객체

### final

- 변수나 메서드 또는 클래스가 "변경 불가능"하도록 만드는 자바 키워드
- 무조건 초기화를 해야 하며 도중에 값 수정이 불가능(상수)
- 데이터를 readOnly로 만들며 객체 내부에서 값의 변환이나 가공을 하지 않겠다고 선언하여 데이터를 지킬 때 사용

### static

- 객체를 생성하지 않고도 변수나 함수를 사용할 수 있게 해주는 키워드
- 정적 변수와 정적 메서드 즉 정적 멤버를 만들 수 있는 키워드. 정적 필드나 정적 메서드는 인스턴스가 아닌 클래스에 고정된다
- 정적 멤버는 클래스가 메모리에 올라갈 때 자동적으로 생성되기 때문에 객체를 따로 생성하지 않아도 호출하여 사용할 수 있다.
- 객체 생성 비용 절약 가능하지만 남용하면 메모리 낭비이다
- GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료 시까지 메모리가 할당된 채로 존재

### TDD란?

- Test Driven Development로 테스트를 먼저 만들고, 테스트를 통과하기 위한 코드를 작성하는 것. 모듈화가 자연스럽게 이루어져, 리팩토링과 유지보수에 용이
- 매우 짧은 개발 사이클의 반복에 의존하는 개발 프로세스로 요구되는 기능에 대한 테스트케이스를 먼저 작성하고 그에 맞는 코드를 작성하여 테스트를 통과한 후에 상황에 맞게 리팩토링

### DDD란?

- Domain Driven Design
- 복잡한 비지니스 요구사항을 해결하기 위해 도메인 중심으로 설계하는 방법으로 비지니스 로직의 이해와 구현에 초점

### 사용자 정의 Exception

- 목적: 클래스의 이름만 봐도 직관적으로 어떤 오류가 발생했는지 알릴 수 있음
- Exception을 상속받은 class들은 checked exception이며 이들은 오류처리를 하지 않으면 컴파일 오류가 발생하므로 반드시 오류 처리를 해야 한다
- 반면 runtimeException을 상속받은 클래스들은 uncheckedException이라고 하며, 오류 처리를 하지 않아도 컴파일에서 오류가 발생되지는 않는다
  - UncheckedException이 트랜잭션 추상화에서의 롤백 대상이다
- 오류 메세지를 조금 더 명확하게 전달하고 디버깅에서 유용한 정보를 제공하고자 할 때 사용자 정의 exception을 사용하는 방식이 도움이 된다

- checked Exception 예시 : FileNotFoundException
- unchecked Exception 예시 : null point exception, array index out of bound exception

### 어노테이션

- 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있음
- @Override @SupressWarning @Component(개발자가 작성한 class를 빈으로 등록) @Bean(외부 라이브러리등을 빈으로 등록할 때 사용)

### generic

- 데이터 타입을 일반화 하는 것으로 클래스와 메서드에서 타입 파라미터를 지정할 수 있도록 해준다.
- 이를 통해 컴파일 시점에서 타입 안정성을 제공, 런타임 과정에서 발생할 수 있는 타입 관련 오류를 줄여줄 수 있다

### Mutable 객체와 Immutable 객체의 차이점

- Mutable 객체는 변경 가능 객체

### 얕은 복사

- 값 자체를 복사하는 것이 아니라 주소값을 복사하여 같은 메모리를 가리킴
- <-> 깊은 복사는 복사된 두 객체가 완전히 독립적인 메모리를 차지

### Call By Reference와 Call By Value의 차이

> 함수에 인자를 전달하는 2가지 방식 이 중 자바는 Call By Value 즉 깊은 복사 방식을 사용!!

- Call By Reference(얕은 복사): 함수에 인자를 전달할 떄 인자의 주소값(참조)를 전달. 함수 내에서 인자 값이 변경되면 원본 인자에도 영향을 미침
- Call By Value(깊은 복사): 함수에 인자를 전달 할 때 인자의 실제 값을 복사하여 원본 인자에 영향을 미치지 않음 ex) int, float

### 동일성과 동등성 비교

- 동일성은 객체의 주소를 비교하는것 Object.equals()
- 동등성은 객체의 같음을 비교 eqauls(), ==

### String StringBuilder StringBuffer

- String은 불변
- StringBuilder와 StringBuffer는 가변 타입
- StringBuilder가 비동기 방식이기에 조금 더 빠르지만, thread safe를 보장해주지 않는다

### 직렬화

- java 객체 -> JSON
  <-> 역직렬화: JSON -> Java 객체

### Collections 프레임워크

- 데이터 그룹을 저장하고 처리하는데 사용되는 인터페이스와 클래스의 집합으로 List, Set, Map 등 다양한 컬렉션 타입을 지원

### JPA

- 자바 표준 API 명세
- 객체와 DB간의 매핑을 쉽게 할 수 있음
- 객체-관계 매핑(ORM): 자바 객체와 데이터베이스 테이블 간의 매핑을 제공
- JPQL: DB 테이블 대신 Java entity를 대상으로 하는 쿼리 언어 -> DBMS 독립적인 쿼리
- 객체 지향 프레임워크이기 때문. 비지니스 로직이 RDBMS에 의존하는 것이 아니라, 자바 코드로 표현될 수 있음 -> 생산성이 높아질 수 있음
- JPQL로 SQL을 추상화하기 때문에 RDBMS Vendor에 상관 없이 동일한 쿼리를 작성해서 같은 동작을 기대할 수 있음

### JPA N+1 문제

- 한 번의 쿼리로 N개의 연관된 엔티티를 조회하려고 할 때 최초의 쿼리 1번과 각각의 N개 entity를 로딩하기 위한 N번의 쿼리가 실행되어 예상보다 많은 쿼리가 실행되는 문제
- fetch join을 사용하여 관련 엔티티를 한 번의 쿼리로 함께 로딩하거나 @EntityGraph 어노테이션을 사용하여 연관된 엔티티를 미리 로딩 가능

### JPA와 Hibernate의 차이점?

- JPA는 자바 어플리케이션에서 관계형 데이터베이스의 데이터를 관리하기 위한 방법을 정의한 API 표준 명세로 자바 객체와 데이터베이스 테이블 간의 매핑을 처리하는 방법을 제공. 즉 구현체가 아니라 명세. 이를 사용하기 위해서는 구현체인 Hibernate 등이 필요
- Hiberanate는 JPA를 구현한 하나의 ORM 라이브러리 중 하나

### 클래스 변수, 인스턴스 변수 , 지역변수

- 클래스 변수: 클래스 당 하나만 존재하는 변수로 클래스의 모든 인스턴스가 공유 (static)
- 인스턴스 변수: 객체마다 개별적으로 가지는 변수로 new 키워드로 생성 -> GC의 관리 대상
- 지역변수: 메서드 내에서 선언되며, 메서드가 실행될 때 생성되고 종료될 때 소멸되는 변수

### JVM

> JDK > JRE > JVM

#### JVM

- 자바 가상 머신
- java compile해서 생긴 class 파일을 컴퓨터가 인식할 수 있는 기계어로 바꾸어 주는 역할을 수행
- jvm을 통해 OS에 독립적인 실행 환경을 가질 수 있다
- 클래스 로더(JVM 내로 클래스를 로드), 실행 엔진(바이트 코드를 실행시키는 역할), 가비지 콜렉터, 런타임 데이터 영역으로 구성
- java 컴파일러가 자바 소스코드를 읽어 자바 바이트코드로 변환시킴 -> class 로더가 class 파일들을 JVM으로 로딩하고 로딩된 class 파일들은 실행 엔진을 통해 해석됨(바이트 코드가 됨) 해석된 바이트 코드는 runtime data area에 배치되어 실질적인 수행이 이루어짐

#### JRE

- java runtime environment
- 자바 실행 환경
- 자바로 만들어진 프로그램을 실행시키기 위한 라이브러리들과 각종 API, JVM이 포함되어 있다. jre로 개발은 할 수 없고, java 실행은 가능하다

#### JDK

- java develop kit의 약자
- 개발자들이 자바로 개발하는데 사용된다. 개발 시 필요한 라이브러리들과 개발 도구를 포함하고 있고 자바를 실행 시킬 수 있어야 하기에 JRE도 포함하고 있다

### Java 컴파일 과정

- 컴파일 타임: 개발자가 .java 파일을 생성하고 build를 하면 java compiler의 javac 명령어를 통해 (.class)바이트코드로 생성한다
- 런타임: 클래스 로더를 통해 JVM 메모리로 로드, 실행 엔진을 통해 기계어로 해석되며, 런타임 데이터 영역에 배치된다

### 컴파일러 vs 인터프리터

- 컴파일러: 전체 프로그램 코드를 먼저 기계어로 변환한 뒤 실행. 컴파일 과정은 시간이 걸리지만 실행 시 빠른 속도 제공
- 인터프리터: 프로그램을 한 줄씩 읽으면서 바로 실행

### 가비지 컬렉션

- 자바의 메모리 관리
- Heap 메모리 영역 중에 더 이상 사용하지 않는 동적 할당된 객체를 탐지해, 자동으로 해제하는 역할을 하는 것
- 더 이상 사용하지 않는 메모리를 자동으로 정리하는 프로세스
- JVM은 가비지 컬렉션을 통한 런타임 메모리 관리도 실행
- 메모리 누수를 막을 수 있지만, GC의 메모리 해제 타이밍을 개발자가 정확히 알기 힘들다

### Runtime Data Area

- JVM이 프로그램을 수행하기 위해 OS로부터 별도로 할당받은 메모리 공간
  - Method Area: static, final 변수
  - Heap Area: new 키워드로 생성된 객체가 저장되는 영역
  - stack area: 지역변수, 파라미터 등이 생성되는 영역. 동적으로 객체를 생성하면 실제 객체는 heap 에 할당되고 해당 레퍼런스만 stack에 저장된다. heap에 있는 객체가 stack에서 참조할 수 없는 경우 GC의 대상이 된다

### 정적 타입 언어

- 컴파일 시 타임(자료형)을 결정.(java, C) 컴파일 시 타입을 정하기 때문에 실행 속도가 빠르고 타입 에러로 인한 문제점을 초기에 발견 가능

### 동적 타입 언어

- 런타임 과정에서 타입을 결정(python) 유연성이 높지만 타입 에러 발생 가능

### 오버로딩과 오버라이딩

- 오버로딩은 매개변수나 타입을 다르게 하여 같은 이름의 메서드를 여러 개 정의하는 것
- 오버라이딩은 상속 관게의 두 클래스가 있을 때 자식 클래스가 부모 클래스의 메서드를 재정의하는 것

### 객체 지향 프로그래밍(OOP)이란?

- 현실 세계의 대상과 그 기능을 객체화하여 표현하는 컴퓨터 프로그래밍 설계 기법
- 명령을 수행하는 주체가 객체이며, 객체들이 프로그래밍 실행의 제어권을 넘겨받아 객체끼리 상호작용하며 프로그램이 실행되도록 하는 설계 기법
- 객체들 간의 상호작용을 코드로 표현한 것
- 추상화(공통된 특성을 파악하고 불필요한 특성 제거)/ 모듈화 / 상속/ 다형성 (하나의 이름으로 많은 상황에 대처하는 것)
- <-> 절차 지향 프로그래밍(모든 프로세스가 위에서 아래로 동작, C)

#### 캡슐화와 은닉화의 차이

- 캡슐화는 객체의 데이터와 메서드를 하나로 묶는 것인 반면 은닉화는 객체의 일부 세부 사항을 외부로부터 숨기는 것(객체의 데이터를 보호하기 위함, 접근 제어자 사용)

### 객체지향 5대 원칙 SOLID

- SRP (단일 책임 원칙): 한 클래스는 하나의 책임만 가져야 한다
- OCP (개방 폐쇄 원칙): 자신의 확장에는 열려 있으나 주변의 변경에는 닫혀 있어야 한다. 다형성을 활용해야 한다
- LSP (리스코프 치환 원칙):하위 클래스의 인스턴스는 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다
- ISP (인터페이스 분리 원칙): 클라이언트는 자신이 사용하지 않는 메서드에 의존해선 안된다. 상황에 맞는 메서드만 제공해야 한다
- DIP (의존관계 역전 원칙): 추상 클래스 또는 상위 클래스는 구현 클래스 또는 하위 클래스에게 의존적이면 안된다

### Java의 특징

- JVM을 사용하기에 운영체제와 독립적이다
- 객체 지향 언어이기에 캡슐화 , 상속, 추상화, 다형성 등의 특징을 가진다
- 컴파일 시 데이터 타입이 결정되는 정적 타입 언어이다

### 클래스/객체/인스턴스

- 클래스: 객체를 생성하기 위한 템플릿
- 객체 : 클래스에 정의된 속성과 메소드를 실제로 가지고 있는 실체
- 인스턴스: 클래스로부터 생성된 구체적인 객체. 클래스 타입으로 메모리에 할당된 구체적인 객체. 객체가 더 큰 개념

### 추상 클래스 vs 인터페이스

- 추상 클래스는 부분적으로 구현된 클래스로, 하나의 클래스가 단 하나만 상속받을 수 있습니다. 구현된 메소드도 포함할 수 있으며, 상속받는 서브 클래스는 모든 추상 메서드를 구현해야 합니다 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용 ex ) Animal - Bird. abstract 키워드로 선언되며, extends 키워드로 상속
- 반면 인터페이스는 모든 메서드가 추상 메서드이어야 하고, 클래스가 여러 개의 인터페이스를 구현할 수 있습니다. (다중 상속이 가능합니다) 상속 받을 서브 클래스에게 구현할 메서드의 원형을 미리 알려주어 구현 객체의 같은 동작을 보장하는 것이 목적입니다. ex) Flyable 인터페이스 - fly 동작 수행하는 클래스에서 사용 interface 키워드로 선언되며 implements 키워드를 통해 상속을 진행

### 접근 제어자

> 객체 지향 프로그래밍 이란 객체들 간의 상호작용을 코드로 표현하는 것인데, 이 때 객체들 간의 관계에 따라서 접근할 수 있는 것과 아닌 것, 권한을 구분할 필요가 존재

- 클래스, 인터페이스, 변수, 함수 등의 접근을 제어하는 지시어로 외부 객체의 무분별한 접근으로부터 데이터를 보호할 수 있다 (데이터의 무결성: 정확하고 일관된 데이터)
- public : 모든 패키지, 모든 class
- protected: 같은 패키지, 모든 클래스 (다른 패키지일 경우 자식 클래스의 접근은 허용)
- default: 같은 패키지
- private: 같은 class

### DAO BO DTO VO

- DAO : data access object

  - DB의 데이터를 조회, 조작하는 객체. DB와 직접적으로 상호작용하는 로직을 비지니스 로직과 분리할 수 있음 (repository, mapper)

- BO : business object

  - 비지니스 로직을 처리하는 객체. (service)

- DTO: data transfer object

  - 객체 간의 데이터 교환이 이뤄질 수 있도록 하는 객체
  - 일반 적으로 특별한 로직을 가지고 있지 않고 Getter와 Setter만을 가짐 (Controller)

- VO (Value Obejct)
  - 데이터의 값 자체에 초점. read only 특성을 가짐. 데이터만을 저장하는 객체

### final

- 변수나 메서드 또는 클래스가 "변경 불가능"하도록 만드는 자바 키워드
- 무조건 초기화를 해야 하며 도중에 값 수정이 불가능(상수)
- 데이터를 readOnly로 만들며 객체 내부에서 값의 변환이나 가공을 하지 않겠다고 선언하여 데이터를 지킬 때 사용

### static

- 객체를 생성하지 않고도 변수나 함수를 사용할 수 있게 해주는 키워드
- 정적 변수와 정적 메서드 즉 정적 멤버를 만들 수 있는 키워드. 정적 필드나 정적 메서드는 인스턴스가 아닌 클래스에 고정된다
- 정적 멤버는 클래스가 메모리에 올라갈 때 자동적으로 생성되기 때문에 객체를 따로 생성하지 않아도 호출하여 사용할 수 있다.
- 객체 생성 비용 절약 가능하지만 남용하면 메모리 낭비이다
- GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료 시까지 메모리가 할당된 채로 존재

### TDD란?

- Test Driven Development로 테스트를 먼저 만들고, 테스트를 통과하기 위한 코드를 작성하는 것. 모듈화가 자연스럽게 이루어져, 리팩토링과 유지보수에 용이

### 사용자 정의 Exception

- 목적: 클래스의 이름만 봐도 직관적으로 어떤 오류가 발생했는지 알릴 수 있음
- Exception을 상속받은 class들은 checked exception이며 이들은 오류처리를 하지 않으면 컴파일 오류가 발생하므로 반드시 오류 처리를 해야 한다
- 반면 runtimeException을 상속받은 클래스들은 uncheckedException이라고 하며, 오류 처리를 하지 않아도 컴파일에서 오류가 발생되지는 않는다
  - UncheckedException이 트랜잭션 추상화에서의 롤백 대상이다
- 오류 메세지를 조금 더 명확하게 전달하고 디버깅에서 유용한 정보를 제공하고자 할 때 사용자 정의 exception을 사용하는 방식이 도움이 된다

- checked Exception 예시 : FileNotFoundException
- unchecked Exception 예시 : null point exception, array index out of bound exception

### 어노테이션

- 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있음
- @Override @SupressWarning @Component(개발자가 작성한 class를 빈으로 등록) @Bean(외부 라이브러리등을 빈으로 등록할 때 사용)

### generic

- 데이터 타입을 일반화 하는 것으로 클래스와 메서드에서 타입 파라미터를 지정할 수 있도록 해준다.
- 이를 통해 컴파일 시점에서 타입 안정성을 제공, 런타임 과정에서 발생할 수 있는 타입 관련 오류를 줄여줄 수 있다

### Mutable 객체와 Immutable 객체의 차이점

- Mutable 객체는 변경 가능 객체

### 얕은 복사

- 값 자체를 복사하는 것이 아니라 주소값을 복사하여 같은 메모리를 가리킴
- <-> 깊은 복사는 복사된 두 객체가 완전히 독립적인 메모리를 차지

### Call By Reference와 Call By Value의 차이

> 함수에 인자를 전달하는 2가지 방식 이 중 자바는 Call By Value 즉 깊은 복사 방식을 사용!!

- Call By Reference(얕은 복사): 함수에 인자를 전달할 떄 인자의 주소값(참조)를 전달. 함수 내에서 인자 값이 변경되면 원본 인자에도 영향을 미침
- Call By Value(깊은 복사): 함수에 인자를 전달 할 때 인자의 실제 값을 복사하여 원본 인자에 영향을 미치지 않음 ex) int, float

### 동일성과 동등성 비교

- 동일성은 객체의 주소를 비교하는것 Object.equals()
- 동등성은 객체의 같음을 비교 eqauls(), ==

### String StringBuilder StringBuffer

- String은 불변
- StringBuilder와 StringBuffer는 가변 타입
- StringBuilder가 비동기 방식이기에 조금 더 빠르지만, thread safe를 보장해주지 않는다

### 직렬화

- java 객체 -> JSON
  <-> 역직렬화: JSON -> Java 객체

### Collections 프레임워크

- 데이터 그룹을 저장하고 처리하는데 사용되는 인터페이스와 클래스의 집합으로 List, Set, Map 등 다양한 컬렉션 타입을 지원

### JPA

- 자바 표준 API 명세
- 객체와 DB간의 매핑을 쉽게 할 수 있음
- 객체-관계 매핑(ORM): 자바 객체와 데이터베이스 테이블 간의 매핑을 제공
- JPQL: DB 테이블 대신 Java entity를 대상으로 하는 쿼리 언어 -> DBMS 독립적인 쿼리
- 객체 지향 프레임워크이기 때문. 비지니스 로직이 RDBMS에 의존하는 것이 아니라, 자바 코드로 표현될 수 있음 -> 생산성이 높아질 수 있음
- JPQL로 SQL을 추상화하기 때문에 RDBMS Vendor에 상관 없이 동일한 쿼리를 작성해서 같은 동작을 기대할 수 있음

### JPA N+1 문제

- 한 번의 쿼리로 N개의 연관된 엔티티를 조회하려고 할 때 최초의 쿼리 1번과 각각의 N개 entity를 로딩하기 위한 N번의 쿼리가 실행되어 예상보다 많은 쿼리가 실행되는 문제
- fetch join을 사용하여 관련 엔티티를 한 번의 쿼리로 함께 로딩하거나 @EntityGraph 어노테이션을 사용하여 연관된 엔티티를 미리 로딩 가능

### JPA와 Hibernate의 차이점?

- JPA는 자바 어플리케이션에서 관계형 데이터베이스의 데이터를 관리하기 위한 방법을 정의한 API 표준 명세로 자바 객체와 데이터베이스 테이블 간의 매핑을 처리하는 방법을 제공. 즉 구현체가 아니라 명세. 이를 사용하기 위해서는 구현체인 Hibernate 등이 필요
- Hiberanate는 JPA를 구현한 하나의 ORM 라이브러리 중 하나

### 클래스 변수, 인스턴스 변수 , 지역변수

- 클래스 변수: 클래스 당 하나만 존재하는 변수로 클래스의 모든 인스턴스가 공유 (static)
- 인스턴스 변수: 객체마다 개별적으로 가지는 변수로 new 키워드로 생성 -> GC의 관리 대상
- 지역변수: 메서드 내에서 선언되며, 메서드가 실행될 때 생성되고 종료될 때 소멸되는 변수

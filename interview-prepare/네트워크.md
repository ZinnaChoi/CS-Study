### 프로토콜

- 통신규약 및 약속. 컴퓨터나 단말기 사이에서 데이터 통신을 원활하게 하기 위해 필요한 통신 규약. ex) TCP, UDP

### IP

- 인터넷 프로토콜 주소
- 컴퓨터 네트워크에서 기기들이 서로를 인식하고 통신하기 위해 사용하는 식별 번호

### 공인 IP와 사설 IP 차이

- 공인 IP: 전세계에서 유일한 IP.

  - 외부에 공개되어 있기 때문에 인터넷에 연결된 다른 장비로부터 접근이 가능
  - 방화벽 등 보안 설정 필요

- 사설 IP: 특정 네트워크 내에서 사용되는 IP 주소
  - 네트워크 안에서 라우터를 통해 할당받는 가상의 주소

### DNS

- Domain: 웹 브라우저를 통해 특정 사이트에 진입을 할 떄 IP 주소를 대신하여 사용하는 주소
- DNS (Domain name System)
  - DNS 서버: 도메인 이름과 매칭된 IP 주소를 확인
  - 호스트의 도메인 이름을 IP로 변환하거나, 그 반대 과정을 수행할 수 있도록 개발된 데이터베이스 시스템

### Proxy Server

- 클라이언트가 자신을 통해서 서버에 간접적으로 접근할 수 있도록 중간에서 대리해주는 서버
  - 캐시된 웹페이지가 있으면 프록시 서버에서 바로 클라이언트에 전송
  - 보안, 바이러스 검출, 방화벽 등

### 방화벽

- 미리 정의된 보안 규칙에 기반한, 들어오고 나가는 네트워크 트래픽을 모니터링하고 제어하는 네트워크 보안 시스템.

### URI, URN, URL

- URI는 네트워크 상 자원을 가리키는 고유 식별자로, 하위 개념으로 URL과 URN이 존재
- URN은 자원의 이름, URL은 자원의 위치를 나타냄

### REST

- 주소와 행위로 자원을 컨트롤하는 통신 규약
- HTTP URI를 통해 자원을 명시하고, HTTP method(Get, Post, Delete, Put, Patch)를 통해 자원에 대한 CRUD operation을 적용하도록 설계된 아키텍처

### HTTP 메서드와 역할

- GET 요청은 서버에 존재하는 데이터를 요청
- POST 요청은 서버에 데이터를 생성
- PUT 요청은 서버에 존재하는 데이터를 수정하거나 존재하지 않으면 생성
- DELETE 요청은 서버에 데이터 제거를 요청
- PATCH 요청은 서버에 존재하는 데이터를 일부 수정

### REST API

- REST의 설계 규약을 올바르게 지킨 API
- 각 자원은 독립적인 인터페이스를 가지며 URL로 식별
- 서버는 클라이언트의 상태를 저장하지 않으며 각 요청은 독립적

### 쿠키 VS 세션

- 보통 웹 환경에서는 클라이언트와 서버가 HTTP 프로토콜을 사용하여 통신 하지만, HTTP 프로토콜은 1. 비연결성 (HTTP가 TCP 연결을 맺고 요청을 보내면 서버는 응답을 보내고 연결이 끊어짐) 2. 무상태(HTTP는 상태를 따로 저장하지 않음) 때문에 응답을 보내면 상태 정보가 사라짐 -> 그래서 쿠키나 세션을 사용

#### 쿠키

- 클라이언트(로컬)에 저장되는 키 - 밸류가 들어있는 작은 데이터 파일. 브라우저에 사용자 정보를 저장
- 웹 서버에 요청을 보낼 때 쿠키를 헤더에 실어서 같이 전송
- 유효기간 설정 가능, 브라우저를 종료해도 정보가 남아있음

#### 세션

- 일정 기간 동안 같은 사용자(클라이언트)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술
- 서버가 클라이언트의 커넥션을 관리. 커넥션이 끊기면 세션이 종료됨
- 서버 단에서 사용자 정보 저장
- 서버는 세션 ID를 이용해 클라이언트를 구분하며, 웹 브라우저가 서버에 접속해 브라우저를 종료할 때까지 세션을 유지하고, 브라우저가 종료되면 삭제된다

### HTTP VS HTTPS

- HTTP: 클라이언트와 서버 간 통신을 위한 통신 규약. 사용자가 웹 사이트에 방문하면, 사용자 브라우저가 웹 서버에 HTTP 요청을 전송, 서버가 HTTP 응답. 이 떄 데이터의 내용이 노출된 상태로 주고받음(HyperText Transfer Protocol)
  - 상태를 가지고 있지 않은 stateless 프로토콜
- HTTPS : 브라우저와 서버가 데이터를 전송하기 전에 안전하고 암호화된 연결을 설정. 암호화 계층을 거쳐서 패킷을 암호화.
  - 대칭키 암호화와 비대칭키 암호화 방식이 모두 사용
  - 비대칭키 암호화는 비용이 크기 때문에 서버와 클라이언트가 주고 받는 모든 메시지를 비대칭키로 암호화하면 오버헤드 발생할 수 있음. 따라서 최초 1회만 비대칭키 암호화 사용, 그 이후는 대칭키 암호화

### HTTP의 발달

#### HTTP 1

- 연결 당 하나의 요청/응답 처리 > RTT의 증가. 패킷 왕복 시간 지연

#### HTTP 1.1

- 지속 연결, 파이프라이닝 등으로 보완했으나 한계 존재
  - HOL 블로킹: 클라이언트의 요청과 서버의 응답이 동기화(첫 요청이 끝나지 않으면 나머지 요청 블로킹)
  - 헤더 크기가 너무 큼(연속된 요청에 대해 동일한 헤더 전송)

#### HTTP 2

- Multiplexed Stream : 하나의 커넥션으로 여러 메시지를 순서 상관 없이 동시에 주고받음
- Stream Prioritization: 리소스 간의 전송 우선 순위 설정
- Header Compression: 헤더 정보 압축
- Server Push: HTML 문서 상에 필요한 리소스를 클라이언트 요청 없이 전송

#### HTTP 3

- QUIC 계층 위에서 동작. UDP 기반(RTT 감소)
- 순방향 오류 수정 매커니즘으로 전송된 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정

### SSL handshake = TLS 핸드세이크

- 전송 계층에서 보안을 제공하는 프로토콜
- HTTPS = HTTP + TLS(SSL)
- 비대칭키, 대칭키 암호화 방식을 모두 사용

### Cors

- cross origin resource sharing
- 교차 출처 리소스 공유
- 출처가 다른 자원들을 공유한다는 뜻으로, 한 출처에 있는 자원에서 다른 출처에 있는 자원에 접근하도록 하는 개념
- 여기서 자원은 프로토콜, 호스트명, 포트 이렇게 3가지를 의미
- CORS error란? 다른 출처에서 접근하지 못하도록 브라우저 단에서 이를 막는 것

### preflight request

- 실제 요청을 보내도 안전한지 판단하기 위해 사전에 보내는 요청
- CORS 를 허용하는지 확인

### https://www.google.com/ 접속 시 발생하는 일

- 0. 리다이랙트, 캐싱(브라우저 캐싱, 프록시 서버의 캐싱)
- 1. DNS 조회 : DNS를 사용하셔 IP 주소를 조회
- 2. TCP 연결: 반환받은 IP 주소를 사용해 TCP 연결. HTTPS 프로토콜 사용 시 기본 포트 443 (cf HTTP 기본 포트 80)
- 3. TLS/SSL 핸드세이크: 보안 연결. 클라이언트와 서버 간 보안 키 교환 및 암호화 방식 협상
- 4. HTTP 요청 전송: 브라우저가 HTTP GET 요청을 서버에 전송
- 5. 서버 응답 : HTTP 프로토콜을 활용해 HTTP 응답 메시지 생성. 웹 페이지를 구성하는 데이터를 응답으로 받음
- 6. 브라우저 렌더링: 사용자에게 화면을 표시

### TCP와 HTTP 차이

- HTTP는 비연결형 프로토콜인 반면 TCP는 연결형 프로토콜
- HTTP는 단방향 통신만 가능, TCP는 양방향 통신 가능
- HTTP는 응용 계층 프로토콜, TCP는 전송 계층 프로토콜

### TCP VS UDP

- TCP는 연결 지향형 프로토콜, UDP는 비연결 지향형 프로토콜로 데이터를 데이터그램 단위로 전송
- TCP는 가상 회선을 만들어 신뢰성을 보장하도록 하기에 신뢰성을 보장하기 위한 절차가 없는 UDP보다 속도가 느림
- TCP는 데이터를 보내고 그에 따른 응답까지 받지만, UDP는 수신자로부터 응답을 받지는 않음
- TCP는 파일 전송과 같은 신뢰성이 중요한 서비스에 사용, UDP는 스트리밍과 같이 연속성이 더 중요한 서비스에 사용됨

### TCP 3 way 4 way handshake

- TCP 3 way handshake는 가상 회선을 수립하는 단계. 클라이언트는 서버에 요청을 전송할 수 있는지, 서버는 클라이언트에게 응답을 전송할 수 있는지 확인하는 과정. 패킷을 주고받음

- 4way handshake는 TCP 연결을 해제하는 단계.

### OSI 7계층, TCP/IP 4계층

- `OSI 7계층`은 네트워크 통신을 구성하는 요소를 7개의 계층으로 표준화 한 것

| 계층 단계 | 계층명           | 설명                                                |
| --------- | ---------------- | --------------------------------------------------- |
| 7         | 응용 계층        | 사용자와 직접 상호작용하는 응용 프로그램들이 포함   |
| 6         | 표현 계층        | 데이터의 형식을 정의하는 계층                       |
| 5         | 세션 계층        | 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층      |
| 4         | 전송 계층        | 최종 수신 프로세스로 데이터의 전송을 담당하는 계층  |
| 3         | 네트워크 계층    | 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층 |
| 2         | 데이터 링크 계층 | 데이터의 물리적인 전송과 에러 검출, 흐름 제어       |
| 1         | 물리 계층        | 데이터를 전기 신호로 바꾸어주는 계층                |

- `TCP/IP 4계층`: 장치들이 인터넷 상에서 데이터를 주고받을 때 쓰는 독립적인 프로토콜의 집합
  - 응용계층 (HTTP, 5-7) 웹 서비스 등 서비스를 실질적으로 client에게 제공
  - 전송 계층 (TCP, UDP, 4) 응용계층에서 받은 메세지를 세그먼트 또는 데이터그램으로 쪼개고, 데이터가 오류 없이 순서대로 전달되도록 함
  - 인터넷 계층 (IP, ARP, 3) : 한 노드에서 다른 노드로 패킷화하여 목적지로 전송
  - 링크 계층: 전선, 광섬유 (PDU: 프레임, 비트, 1-2)

### graphql

- REST API의 대안으로 사용되는 데이터 쿼리 및 조작 언어
- 하나의 엔드포인트를 사용하여 다양한 데이터 요청을 처리한다는 특징 존재
- sql과 마찬가지로 쿼리 언어이지만, sql은 데이터베이스에 저장된 데이터를 효율적으로 가져오는 것이 목적이라면, gp1은 웹 클라이언트가 데이터를 서버로부터 효율적으로 가져오는 것이 목적
  - query는 select 문에 사용 , mutation은 CUD 연산에 사용

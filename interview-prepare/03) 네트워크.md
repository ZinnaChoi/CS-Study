### REST

| -        | 설명                                                                                                                                                         |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| REST     | - 주소와 행위로 자원을 컨트롤하는 통신 규약<br>- HTTP URI를 통해 자원을 명시하고, HTTP 메서드를 통해 자원에 대한 CRUD Operation을 적용하도록 설계된 아키텍처 |
| REST API | - REST의 설계 규약을 올바르게 지킨 API <br>- 서버는 클라이언트의 상태를 저장하지 않으며 각 요청은 독립적                                                     |

---

### HTTP 메서드와 역할

| Method | 역할                                                     |
| ------ | -------------------------------------------------------- |
| GET    | 서버에 존재하는 데이터를 요청                            |
| POST   | 서버에 데이터를 생성                                     |
| PUT    | 서버에 존재하는 데이터를 수정하거나 존재하지 않으면 생성 |
| DELETE | 서버에 존재하는 데이터 제거를 요청                       |
| PATCH  | 서버에 존재하는 데이터 일부 수정                         |

---

### 쿠키 VS 세션

#### 사용 이유

> 보통 웹 환경에서는 클라이언트와 서버가 HTTP 프로토콜을 사용하여 통신 하지만, HTTP 프로토콜은 1. 비연결성 (HTTP가 TCP 연결을 맺고 요청을 보내면 서버는 응답을 보내고 연결이 끊어짐) 2. 무상태(HTTP는 상태를 따로 저장하지 않음) 때문에 응답을 보내면 상태 정보가 사라짐 -> 그래서 쿠키나 세션을 사용

#### 비교

| 구분             | 쿠키                                                   | 세션                                                 |
| ---------------- | ------------------------------------------------------ | ---------------------------------------------------- |
| 저장 위치        | 클라이언트(로컬, 브라우저)                             | 서버                                                 |
| 데이터 저장 형태 | 키 - 밸류가 들어있는 작은 데이터 파일                  | 서버에서 관리하는 세션 ID를 통해 사용자 정보 저장    |
| 통신 방식        | 웹 서버에 요청을 보낼 때 헤더에 실어 전송              | 서버가 클라이언트의 커넥션을 관리하여 세션 ID로 구분 |
| 유효기간         | 설정 가능, 브라우저 종료 후에도 정보 유지              | 브라우저 종료 시 삭제, 일정 기간 동안만 유지         |
| 특징             | 브라우저에 사용자 정보를 저장, 사용자별 정보 보관 가능 | 서버 자원 사용, 보안상 비교적 안전                   |

---

### CORS

| 항목                                 | 설명                                                                                                                                |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------- |
| CORS (Cross Origin Resource Sharing) | 한 출처의 자원에서 다른 출처의 자원에 접근할 수 있도록 하는 웹 보안 메커니즘. 여기서 출처는 프로토콜, 호스트명, 포트의 조합을 의미. |
| CORS error                           | 다른 출처의 자원에 접근하려 할 때, 해당 출처에서 자원 공유를 허용하지 않는 경우 브라우저가 발생시키는 오류.                         |
| Preflight Request                    | 실제 요청을 서버에 보내기 전에, 해당 요청이 안전한지 확인하기 위해 브라우저가 서버에 보내는 사전 요청. (CORS를 허용하는지 확인)     |

---

### https://www.google.com/ 접속 시 발생하는 일

| STEP | 설명                                                                                                      |
| ---- | --------------------------------------------------------------------------------------------------------- |
| 0    | 리다이랙트, 캐싱(브라우저 캐싱, 프록시 서버의 캐싱)                                                       |
| 1    | DNS 조회 : DNS를 사용하셔 IP 주소를 조회                                                                  |
| 2    | TCP 연결: 반환받은 IP 주소를 사용해 TCP 연결. HTTPS 프로토콜 사용 시 기본 포트 443 (cf HTTP 기본 포트 80) |
| 3    | TLS/SSL 핸드세이크: 보안 연결. 클라이언트와 서버 간 보안 키 교환 및 암호화 방식 협상                      |
| 4    | HTTP 요청 전송: 브라우저가 HTTP GET 요청을 서버에 전송                                                    |
| 5    | 서버 응답 : HTTP 프로토콜을 활용해 HTTP 응답 메시지 생성. 웹 페이지를 구성하는 데이터를 응답으로 받음     |
| 6    | 브라우저 렌더링: 사용자에게 화면을 표시                                                                   |
|      |

---

### 네트워크 용어

| 용어                                  | 설명                                                                                                                |
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| **프로토콜 (Protocol)**               | 컴퓨터나 단말기 사이의 데이터 통신을 원활하게 하기 위한 통신 규약. 예: TCP, UDP                                     |
| **IP (Internet Protocol) 주소**       | 컴퓨터 네트워크에서 기기들이 서로를 인식하고 통신하기 위해 사용하는 식별 번호.                                      |
| **DNS (Domain Name System)**          | 도메인 이름과 매칭된 IP 주소를 확인하는 시스템. 호스트의 도메인 이름을 IP로 변환하거나 그 반대 과정을 수행.         |
| **IP 주소 종류**                      | 공인 IP는 전 세계에서 유일하며 외부 접근 가능. 사설 IP는 내부 네트워크 용도, 외부 접근 불가.                        |
| **프록시 서버 (Proxy Server)**        | 클라이언트가 서버에 간접적으로 접근할 수 있도록 중간에서 대리해주는 서버. 캐싱, 보안, 바이러스 검출 등의 기능 제공. |
| **방화벽 (Firewall)**                 | 미리 정의된 보안 규칙을 바탕으로 들어오고 나가는 네트워크 트래픽을 모니터링하고 제어하는 네트워크 보안 시스템.      |
| **URI (Uniform Resource Identifier)** | 네트워크 상 자원을 가리키는 고유 식별자. URL과 URN을 포함하는 더 넓은 개념.                                         |
| **URN (Uniform Resource Name)**       | 자원의 이름을 나타내며, 그 자원이 어디에 있든 그것을 식별할 수 있는 이름.                                           |
| **URL (Uniform Resource Locator)**    | 자원의 위치를 나타내며, 그 자원이 어떻게 접근할 수 있는지를 명시.                                                   |

---

### 핸드세이크

![alt text](img/TCP핸드세이크.png)

| 핸드세이크 유형          | 설명                                                                                                                                                                                                                                                                                    |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **TCP 3-way 핸드세이크** | 가상 회선을 수립하는 과정. <br>1) 클라이언트가 서버에 SYN을 보내 연결 요청. <br>2) 서버는 SYN-ACK로 응답. <br>3) 클라이언트는 ACK로 응답하여 연결을 확립. 이 과정을 통해 양쪽 모두 데이터 전송 준비가 완료됨을 확인.                                                                    |
| **TCP 4-way 핸드세이크** | TCP 연결을 종료하는 과정. <br>1) 클라이언트가 FIN을 보내 연결 종료 요청. <br>2) 서버는 ACK로 응답, 클라이언트는 연결 종료 준비가 됨을 알림. <br>3) 서버에서 모든 데이터 전송이 완료되면 FIN을 클라이언트에게 전송. <br>4) 클라이언트는 ACK로 응답하며, 이후 연결 종료.                  |
| **SSL/TLS 핸드세이크**   | 보안된 연결을 수립하는 과정. <br>1) 클라이언트와 서버 간에 암호화 방식 협상. <br>2) 서버는 인증서를 클라이언트에게 전송. <br>3) 클라이언트는 인증서 검증 및 비대칭키 암호화를 사용하여 세션 키 생성, 이를 서버에 전송. <br>4) 서버와 클라이언트는 세션 키를 사용하여 대칭키 암호화 방식 |

---

### HTTP VS HTTPS

| 구분 | HTTP                                                                    | HTTPS                                                                                 |
| ---- | ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| 정의 | 클라이언트와 서버 간의 통신 규약. 데이터가 암호화되지 않은 채로 전송됨. | HTTP에 데이터 암호화가 추가된 프로토콜. 데이터 전송 전 안전한 연결을 설정.            |
| 특징 | 상태를 가지고 있지 않는 Stateless 프로토콜.                             | 대칭키와 비대칭키 암호화 방식을 사용하여 데이터를 암호화.(최초 1회만 비대칭키 암호화) |
| 보안 | 데이터가 암호화되지 않아 정보 유출 가능성이 있음.                       | SSL/TLS를 통해 데이터를 암호화하여 보안성이 높음.                                     |

---

### HTTP VS TCP

| HTTP               | TCP                |
| ------------------ | ------------------ |
| 비연결형 프로토콜  | 연결형 프로토콜    |
| 단방향 통신만 가능 | 양방향 통신 가능   |
| 응용 계층 프로토콜 | 전송 계층 프로토콜 |

---

### TCP VS UDP

| 구분      | TCP                                                                                         | UDP                                                                         |
| --------- | ------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------- |
| 특성      | 연결 지향형 프로토콜, 가상 회선을 만들어 신뢰성 보장. 데이터를 보내고 그에 따른 응답을 받음 | 비연결 지향형 프로토콜, 신뢰성 보장하지 않음. 수신자로부터 응답을 받지 않음 |
| 속도      | 상대적으로 느림, 데이터의 순차적 전달과 신뢰성이 중요할 때 사용.                            | 상대적으로 빠름, 실시간 스트리밍 등 연속성이 중요한 서비스에 사용.          |
| 사용 사례 | 파일 전송, 이메일 전송 등 신뢰성이 중요한 경우.                                             | 비디오 스트리밍, 온라인 게임 등 실시간성이 중요한 경우.                     |

---

### HTTP의 발달

| STEP     | 설명                                                                                                                                                                                                                                                                   |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| HTTP1    | - 연결 당 하나의 요청/응답 처리 > RTT 증가. 패킷 왕복 시간 지연                                                                                                                                                                                                        |
| HTTP 1.1 | - 지속 연결, 파이프라이닝 등으로 보완했으나 한계 존재 <br> - HOL 블로킹: 클라이언트의 요청과 서버의 응답이 동기화(첫 요청이 끝나지 않으면 나머지 요청 블로킹) <br>- 헤더 크기가 너무 큼. 연속된 요청에 대해 동일한 헤더 전송                                           |
| HTTP 2   | - Multiplexed Stream: 하나의 커넥션으로 여러 메시지를 순서 상관 없이 동시에 주고받음 <br>- Stream Prioritization: 리소스 간의 전송 우선 순위 설정 <br>- Header Compression: 헤더 정보 압축 <br>- Server push: HTML 문서 상에 필요한 리소스를 클라이언트 요청 없이 전송 |
| HTTP 3   | - QUIC 계층 위에서 동작. UDP 기반 (RTT 감소) <br> - 순방향 오류 수정 매커니즘으로 전송된 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정                                                                                                                          |
|          |

---

### OSI 7계층, TCP/IP 4계층

- 네트워크 통신을 구성하는 요소를 7개/4개의 계층으로 표준화 한 것

| OSI 7계층 (계층명)  | 설명                                            | TCP/IP 4계층 매칭     |
| ------------------- | ----------------------------------------------- | --------------------- |
| 7. 응용 계층        | 사용자와 직접 상호작용하는 응용 프로그램 포함   | 응용 계층 (HTTP 등)   |
| 6. 표현 계층        | 데이터 형식 정의, 암호화 및 압축 처리           |                       |
| 5. 세션 계층        | 통신 세션 관리, 연결 유지 및 중단 처리          |                       |
| 4. 전송 계층        | 데이터의 오류 없는 순서대로 전달, 세그먼트 생성 | 전송 계층 (TCP, UDP)  |
| 3. 네트워크 계층    | 패킷 전송 및 라우팅 관리                        | 인터넷 계층 (IP, ARP) |
| 2. 데이터 링크 계층 | 물리적 주소 정의, 에러 검출 및 흐름 제어        | 링크 계층             |
| 1. 물리 계층        | 데이터를 전기 신호로 변환                       |                       |

---

### Graphql

| 항목                    | 설명                                                                                                                                                                                                                                      |
| ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **GraphQL**             | REST API의 대안으로 사용되는 데이터 쿼리 및 조작 언어. 클라이언트가 필요한 데이터의 구조를 명시적으로 요청하여 서버로부터 받아올 수 있게 설계된 언어.                                                                                     |
| **특징**                | 하나의 엔드포인트를 통해 다양한 데이터 요청 및 조작이 가능. 클라이언트가 요청하는 데이터의 형태에 맞춰 정확히 그 데이터만을 응답으로 받아 효율적인 데이터 통신을 지원.                                                                    |
| **REST API와의 차이점** | REST는 리소스 간의 고정된 URL(엔드포인트)에 요청을 보내는 반면, GraphQL은 단일 엔드포인트를 통해 필요한 모든 데이터를 쿼리 형태로 요청. 이는 오버페칭(필요 이상의 데이터 요청) 및 언더페칭(필요한 데이터를 충분히 받지 못함) 문제를 해결. |
| **쿼리 (Query)**        | 데이터를 읽기 위한 요청. SQL의 SELECT문과 유사하며, 클라이언트가 요청한 형식과 정확히 일치하는 데이터를 검색하여 반환.                                                                                                                    |
| **변형 (Mutation)**     | 데이터를 생성(Create), 수정(Update), 삭제(Delete)하기 위한 요청. 서버 상의 데이터를 변경하는 작업을 수행.                                                                                                                                 |

---

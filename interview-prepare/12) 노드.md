# Node.js 면접 대비

## 왜 Node.js를 선택했나요?

**답변**:
저희 프로젝트는 여러 API를 조합하는 BFF 서버였습니다. Node.js를 선택한 이유는:

1. **I/O 집약적 작업에 최적화** - 여러 백엔드 API를 병렬로 호출하고 조합하는 작업이 많았고, Promise.all로 간단하게 병렬 처리가 가능했습니다.

2. **경량화 & 빠른 시작** - Spring Boot는 시작에 10초 이상 걸리지만, Node.js는 1초 안에 시작돼서 배포 속도가 빨랐습니다. 메모리도 적게 씀 (Spring 500MB vs Node.js 100MB)

3. **빠른 개발 & 유연성** - TypeScript의 점진적 타입 시스템 덕분에 필요한 곳만 타입을 강하게 하고, 빠르게 바뀌는 부분은 유연하게 처리할 수 있었습니다.

4. **JSON 처리가 네이티브** - API 서버 특성상 JSON을 많이 다루는데, JavaScript는 JSON이 native라서 변환 오버헤드가 없고 다루기 편했습니다.

**Spring 대비 장점**:
- 시작 시간: Spring Boot 10초 vs Node.js 1초
- 메모리: Spring 500MB vs Node.js 100MB
- I/O 성능: 동시 요청 많을 때 Node.js가 메모리 효율적
- 개발 속도: 타입 시스템이 유연해서 빠른 프로토타이핑 가능

**Spring은 언제?** 복잡한 비즈니스 로직, 무거운 트랜잭션, CPU 집약적 작업, 엔터프라이즈 환경

---

## Node.js 싱글 스레드인데 어떻게 동시 요청을 처리하나요?

**답변**:
Event Loop와 Non-blocking I/O 덕분입니다.

**핵심 동작 방식**:
Node.js는 싱글 스레드지만, I/O 작업(DB 조회, API 호출 등)을 만나면:
1. **OS에게 작업을 위임**하고
2. **메인 스레드는 다른 요청을 계속 처리**합니다
3. **I/O 작업이 완료되면** OS가 알려주고, Event Loop가 콜백을 실행합니다

**Event Loop 동작 순서**:
1. 메인 스레드의 **Call Stack이 비었는지 확인**
2. 비었으면 **Microtask Queue 먼저 확인** → Call Stack에 넣어서 실행
3. Microtask Queue가 비었으면 → **Task Queue 확인** → Call Stack에 넣어서 실행
4. 1번으로 돌아가서 무한 반복

**우선순위**:
1. 동기 코드 (Call Stack)
2. Microtask (Promise.then) ← 먼저!
3. Macrotask (setTimeout) ← 나중!

---

## Promise가 뭔가요?

**답변**:
Promise는 나중에 완료될 비동기 작업의 결과를 나타내는 객체입니다. 3가지 상태가 있습니다:
- **Pending**: 작업 진행 중
- **Fulfilled**: 작업 성공
- **Rejected**: 작업 실패

**꼬리 질문: Promise는 항상 비동기인가요?**
**아닙니다!**
- `new Promise(executor)` 생성자는 **동기 실행**
- `.then()/.catch()` 콜백은 **비동기 실행** (Microtask Queue)

```javascript
console.log('1');
const promise = new Promise((resolve) => {
  console.log('2');  // 동기 실행
  resolve('3');
});
console.log('4');
promise.then(value => console.log(value));  // 비동기
console.log('5');
// 출력: 1 → 2 → 4 → 5 → 3
```

---

## await은 블로킹 아닌가요?

**답변**:
아닙니다! await은 **async 함수 내부만** 일시 정지시키고, **메인 스레드는 계속 실행**됩니다.

```javascript
async function example() {
  console.log('1');
  const data = await fetchData();  // 함수만 일시 정지
  console.log('2', data);
}

example();
console.log('3');  // 메인 스레드는 계속 실행
// 출력: 1 → 3 → 2
```

**동작 원리**:
1. `await`을 만나면 → async 함수만 일시 정지
2. I/O 작업을 OS/libuv에 위임
3. 메인 스레드는 다른 코드/요청 계속 처리
4. 작업 완료 → Microtask Queue에 적재 → Event Loop가 함수 재개

---

## 병렬 처리는 어떻게 하나요?

**답변**:
독립적인 비동기 작업은 `Promise.all`로 병렬 처리합니다.

```javascript
// 순차 실행 (6초)
const user = await fetchUser();      // 3초
const orders = await fetchOrders();  // 3초

// 병렬 실행 (3초)
const [user, orders] = await Promise.all([
  fetchUser(),    // 동시 시작
  fetchOrders()   // 동시 시작
]);
```

**Promise 병렬 처리 메서드**:
- **Promise.all**: 하나라도 실패하면 전체 실패
- **Promise.allSettled**: 모든 결과 받음
- **Promise.race**: 가장 먼저 완료된 것만

---

## Node.js에서 CPU 집약적 작업은?

**답변**:
Node.js는 CPU 작업에 약하므로 다음 방법으로 해결합니다:
- **Cluster**: CPU 코어만큼 프로세스 생성 (PM2 사용, 실무에서 가장 많이 씀)
- **Worker Threads**: 별도 스레드에서 CPU 작업 처리
- **외부 서비스 분리**: Python/Go 등으로 분리

---

## 트랜잭션은 어떻게 처리하나요?

**답변**:
트랜잭션은 여러 DB 작업을 하나로 묶어 All or Nothing을 보장합니다.

```javascript
// Sequelize 예시
await sequelize.transaction(async (t) => {
  const product = await Product.findOne({
    where: { id: productId },
    transaction: t
  });

  if (product.stock < 1) {
    throw new Error('재고 부족');
  }

  await Order.create({ userId, productId }, { transaction: t });
  await product.decrement('stock', { transaction: t });
  // 둘 다 성공하거나, 둘 다 실패 (원자성 보장)
});
```

---

## 동시성 제어는 어떻게 하나요?

**답변**:
Race Condition을 방지하기 위한 방법들입니다.

**1. DB Atomic 연산 (가장 간단 ⭐)**
```javascript
const [updated] = await Product.update(
  { stock: sequelize.literal('stock - 1') },
  {
    where: {
      id: 1,
      stock: { [Op.gt]: 0 }
    }
  }
);
```

**2. Pessimistic Lock (비관적 락)**
```javascript
await sequelize.transaction(async (t) => {
  const product = await Product.findOne({
    where: { id: 1 },
    lock: t.LOCK.UPDATE,
    transaction: t
  });
  // 작업 수행
});
```

**3. Redis 분산 락 (MSA 환경 ⭐)**
- 여러 서버에서 동시 접근 방지 (Redlock 라이브러리 사용)

**선택 기준**:
- **단순 재고 차감**: DB Atomic 연산 (가장 빠름)
- **복잡한 주문 처리**: Pessimistic Lock
- **게시글 수정**: Optimistic Lock
- **MSA 환경**: Redis 분산 락

---

## Spring (Kotlin) vs Node.js 선택 기준은?

**답변**:
프로젝트 특성에 따라 선택합니다.

| 기준 | Node.js 선택 | Spring (Kotlin) 선택 |
|------|-------------|---------------------|
| **I/O 특성** | I/O 집약적, 동시 요청 많음 | CPU 집약적, 복잡한 비즈니스 로직 |
| **성능** | 가벼움 (시작 1초, 메모리 100MB) | 무거움 (시작 10초, 메모리 500MB) |
| **트랜잭션** | 단순한 CRUD | 복잡한 트랜잭션, 정합성 중요 |
| **팀 역량** | JavaScript/TypeScript 익숙 | Java/Kotlin 익숙 |
| **사용 사례** | API 서버, 실시간 서비스, BFF | 결제, 정산, 엔터프라이즈 |

**실무 사용 사례**:
- **어드민 서버**: Node.js (I/O 집약적, 빠른 개발)
- **메인 서비스**: Spring (복잡한 비즈니스 로직, 트랜잭션)
- **배치 처리**: Spring Batch

---

## 면접 핵심 요약

| 질문 | 핵심 답변 |
|------|---------|
| **싱글 스레드인데 동시 처리?** | Event Loop + Non-blocking I/O (OS에 I/O 위임) |
| **DB는 워커 스레드 사용?** | OS 비동기 I/O 사용 (CPU 안 씀) |
| **Promise는 항상 비동기?** | 생성자는 동기, .then()만 비동기 |
| **await은 블로킹?** | 함수만 멈춤, 메인 스레드 계속 진행 |
| **Microtask vs Macrotask?** | Microtask(Promise) 먼저 → Macrotask(setTimeout) 나중 |
| **Promise.all 쓰는 이유?** | 병렬 실행으로 속도 향상 (6초 → 3초) |
| **CPU 작업은?** | Cluster (PM2) 또는 외부 서비스 분리 |
| **트랜잭션은?** | All or Nothing 보장 (주문+재고) |
| **동시성 제어는?** | DB Atomic 연산 (단일), Redis Lock (분산) |
| **Java vs Node.js?** | I/O 많으면 Node.js, CPU 많으면 Java |

---

## 실전 답변 예시

**"왜 Node.js를 선택했나요?"**
저희 프로젝트는 여러 API를 조합하는 I/O 집약적 작업이 많아서 Node.js를 선택했습니다. Promise.all로 병렬 처리가 간편했고, TypeScript로 프론트와 타입을 공유하면서 개발 속도도 빨랐습니다. 다만 CPU 작업은 약하기 때문에, 무거운 계산은 Cluster나 외부 서비스로 분리했습니다.

**"Node.js 성능 최적화 경험은?"**
Promise.all로 병렬 처리해서 API 응답 시간을 6초에서 3초로 50% 단축했습니다. 자주 조회하는 데이터는 Redis 캐싱으로 DB 부하를 70% 줄였고, PM2 Cluster 모드로 트래픽 처리량을 4배 늘렸습니다.

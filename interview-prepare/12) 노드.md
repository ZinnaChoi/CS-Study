# Node.js 면접 대비

## 왜 Node.js를 선택했나요?

**답변**:
저희 프로젝트는 여러 API를 조합하는 BFF 서버였습니다. Node.js를 선택한 이유는:

1. **I/O 집약적 작업에 최적화** - 여러 백엔드 API를 병렬로 호출하고 조합하는 작업이 많았고, Promise.all로 간단하게 병렬 처리가 가능했습니다.

2. **경량화 & 빠른 시작** - Spring Boot는 시작에 10초 이상 걸리지만, Node.js는 1초 안에 시작돼서 배포 속도가 빨랐습니다. 메모리도 적게 씀 (Spring 500MB vs Node.js 100MB)

3. **빠른 개발 & 유연성** - 어드민 특성상 기능 변경이 잦았는데, TypeScript의 점진적 타입 시스템 덕분에 필요한 곳만 타입을 강하게 하고, 빠르게 바뀌는 부분은 유연하게 처리할 수 있었습니다. 프론트와 타입 공유도 가능했고요.

4. **JSON 처리가 네이티브** - API 서버 특성상 JSON을 많이 다루는데, JavaScript는 JSON이 native라서 변환 오버헤드가 없고 다루기 편했습니다.

**Spring 대비 장점**:
- 시작 시간: Spring Boot 10초 vs Node.js 1초
- 메모리: Spring 500MB vs Node.js 100MB
- I/O 성능: 동시 요청 많을 때 Node.js가 메모리 효율적
- 개발 속도: 타입 시스템이 유연해서 빠른 프로토타이핑 가능

**Spring은 언제?** 복잡한 비즈니스 로직, 무거운 트랜잭션, CPU 집약적 작업, 엔터프라이즈 환경

---

## Node.js 싱글 스레드인데 어떻게 동시 요청을 처리하나요?

**답변**:
Event Loop와 Non-blocking I/O 덕분입니다.

**핵심 동작 방식**:
Node.js는 싱글 스레드지만, I/O 작업(DB 조회, API 호출 등)을 만나면:
1. **OS에게 작업을 위임**하고
2. **메인 스레드는 다른 요청을 계속 처리**합니다
3. **I/O 작업이 완료되면** OS가 알려주고, Event Loop가 콜백을 실행합니다

**Event Loop 동작 순서**:
1. 메인 스레드의 **Call Stack이 비었는지 확인**
2. 비었으면 **Microtask Queue 먼저 확인** -> Call Stack에 넣어서 실행
3. Microtask Queue가 비었으면 -> **Task Queue 확인** -> Call Stack에 넣어서 실행
4. 1번으로 돌아가서 무한 반복

**I/O 작업 처리**:
- **DB/HTTP 요청**: OS 비동기 I/O 사용 (CPU 안 씀, 네트워크 대기만)
- **파일 읽기/암호화**: libuv 워커 스레드 사용 (CPU 필요)

**왜 I/O에 강한가?**
1000개 DB 요청이 동시에 왔을 때:
- **Java/Spring**: 1000개 스레드 생성 -> 메모리 많이 씀 (1GB+)
- **Node.js**: 메인 스레드 1개로 처리 -> 메모리 적게 씀 (100MB)

**우선순위**:
1. 동기 코드 (Call Stack)
2. Microtask (Promise.then) - 먼저
3. Macrotask (setTimeout) - 나중

---

## Promise가 뭔가요?

**답변**:
Promise는 나중에 완료될 비동기 작업의 결과를 나타내는 객체입니다. 3가지 상태가 있습니다:
- **Pending**: 작업 진행 중
- **Fulfilled**: 작업 성공
- **Rejected**: 작업 실패

**왜 사용하나요?**
Callback Hell(콜백 지옥)을 해결하고 코드 가독성을 높이기 위해서입니다.

```javascript
// async/await로 깔끔하게
async function fetchData() {
  try {
    const user = await getUser();
    const orders = await getOrders(user.id);
    return orders;
  } catch (err) {
    console.error(err);
  }
}
```

**꼬리 질문: Promise는 항상 비동기인가요?**
**아닙니다!**
- `new Promise(executor)` 생성자는 **동기 실행**
- `.then()/.catch()` 콜백은 **비동기 실행** (Microtask Queue)

```javascript
console.log('1');
const promise = new Promise((resolve) => {
  console.log('2');  // 동기 실행
  resolve('3');
});
console.log('4');
promise.then(value => console.log(value));  // 비동기
console.log('5');
// 출력: 1 -> 2 -> 4 -> 5 -> 3
```

---

## await은 블로킹 아닌가요?

**답변**:
아닙니다! await은 **async 함수 내부만** 일시 정지시키고, **메인 스레드는 계속 실행**됩니다.

```javascript
async function example() {
  console.log('1');
  const data = await fetchData();  // 함수만 일시 정지
  console.log('2', data);
}

example();
console.log('3');  // 메인 스레드는 계속 실행
// 출력: 1 -> 3 -> 2
```

**동작 원리**:
1. `await`을 만나면 -> async 함수만 일시 정지
2. I/O 작업을 OS/libuv에 위임
3. 메인 스레드는 다른 코드/요청 계속 처리
4. 작업 완료 -> Microtask Queue에 적재 -> Event Loop가 함수 재개

**왜 await을 쓰나요?**
- 동기 코드처럼 읽기 쉬움
- try-catch로 깔끔한 에러 처리
- 메인 스레드는 여전히 Non-blocking

---

## Event Loop 단계와 우선순위?

**답변**:
Event Loop는 **"Call Stack이 비는 순간"을 계속 감시하는 감시자**입니다.

**Event Loop 동작 방식**:
1. **Call Stack이 비었는지 확인**
2. 비었으면 **Microtask Queue 먼저 확인** -> 있으면 Call Stack에 넣어서 실행
3. Microtask Queue가 비었으면 -> **Task Queue 확인** -> 있으면 Call Stack에 넣어서 실행
4. 1번으로 돌아가서 무한 반복

**Event Loop 5단계**:
1. **Timers**: setTimeout, setInterval
2. **Pending**: 시스템 콜백
3. **Poll**: I/O 작업 (DB, 파일, 네트워크) - 가장 중요
4. **Check**: setImmediate
5. **Close**: 소켓 종료

**우선순위** (면접 단골):
1. **동기 코드** (Call Stack)
2. **process.nextTick** (최우선)
3. **Microtask** (Promise.then) - 먼저
4. **Macrotask** (setTimeout, setImmediate) - 나중

```javascript
console.log('0');                                // 동기
setTimeout(() => console.log('1'), 0);           // Macrotask
Promise.resolve().then(() => console.log('3'));  // Microtask
process.nextTick(() => console.log('4'));        // 최우선
// 출력: 0 -> 4 -> 3 -> 1
```

**핵심**: Event Loop는 Microtask Queue를 먼저 비운 후 -> Task Queue를 처리합니다!

---

## 병렬 처리는 어떻게 하나요?

**답변**:
독립적인 비동기 작업은 `Promise.all`로 병렬 처리합니다.

```javascript
// 순차 실행 (6초)
const user = await fetchUser();      // 3초
const orders = await fetchOrders();  // 3초

// 병렬 실행 (3초)
const [user, orders] = await Promise.all([
  fetchUser(),    // 동시 시작
  fetchOrders()   // 동시 시작
]);
```

**Promise 병렬 처리 메서드**:
- **Promise.all**: 하나라도 실패하면 전체 실패 (결제 처리, 필수 데이터)
- **Promise.allSettled**: 모든 결과 받음 (로그 수집, 선택적 데이터)
- **Promise.race**: 가장 먼저 완료된 것만 (다중 서버 요청, 타임아웃)

---

## Node.js에서 CPU 집약적 작업은?

**답변**:
Node.js는 CPU 작업에 약하므로 다음 방법으로 해결합니다:
- **Cluster**: CPU 코어만큼 프로세스 생성 (PM2 사용, 실무에서 가장 많이 씀)
- **Worker Threads**: 별도 스레드에서 CPU 작업 처리
- **외부 서비스 분리**: Python/Go 등으로 분리

---

## 트랜잭션은 어떻게 처리하나요?

**답변**:
트랜잭션은 여러 DB 작업을 하나로 묶어 All or Nothing을 보장합니다.

```javascript
// Sequelize 예시
await sequelize.transaction(async (t) => {
  const product = await Product.findOne({
    where: { id: productId },
    transaction: t
  });

  if (product.stock < 1) {
    throw new Error('재고 부족');
  }

  await Order.create({ userId, productId }, { transaction: t });
  await product.decrement('stock', { transaction: t });
  // 둘 다 성공하거나, 둘 다 실패 (원자성 보장)
});
```

**실무 사용 케이스**:
- 주문 생성 + 재고 감소
- 결제 + 포인트 차감
- 계좌 이체 (출금 + 입금)

---

## 동시성 제어는 어떻게 하나요?

**답변**:
Race Condition은 여러 작업이 동시에 실행될 때 실행 순서에 따라 결과가 달라지는 상황입니다.

재고 차감 같은 동시 요청 시 Race Condition을 방지하기 위한 방법들입니다.

**1. DB Atomic 연산 (가장 간단)**
```javascript
// DB에서 원자적으로 처리
const [updated] = await Product.update(
  { stock: sequelize.literal('stock - 1') },
  {
    where: {
      id: 1,
      stock: { [Op.gt]: 0 }  // 재고 > 0일 때만
    }
  }
);
```

**2. Pessimistic Lock (비관적 락)**
```javascript
// SELECT FOR UPDATE로 레코드 잠금
await sequelize.transaction(async (t) => {
  const product = await Product.findOne({
    where: { id: 1 },
    lock: t.LOCK.UPDATE,  // 다른 트랜잭션 대기
    transaction: t
  });
  // 작업 수행
});
```

**3. Optimistic Lock (낙관적 락)**
version 컬럼을 두고, 수정 시 version이 같은지 확인 (다르면 에러)

**4. Redis 분산 락 (MSA 환경)**
여러 서버에서 동시 접근 방지 (Redlock 라이브러리 사용)

**선택 기준**:
- **단순 재고 차감**: DB Atomic 연산 (가장 빠름)
- **복잡한 주문 처리**: Pessimistic Lock (여러 테이블 수정)
- **게시글 수정**: Optimistic Lock (충돌 적음)
- **MSA 환경**: Redis 분산 락

---

## 구글 로그인(SSO)은 어떻게 구현했나요?

**답변**:
OAuth 2.0으로 구글 SSO를 구현했고, 로그인 상태(세션)는 DynamoDB에 저장했습니다.

**SSO vs OAuth**:
- **SSO**: 하나의 계정(구글)으로 여러 서비스 로그인 (목표)
- **OAuth 2.0**: SSO를 구현하는 기술/프로토콜 (방법)

**흐름 (OAuth 2.0)**:
```
1. 구글 로그인 -> OAuth로 사용자 이메일/이름 받음
2. DynamoDB에 세션 저장 (비밀번호 저장 안 함!)
   { sessionId, email, name, role, ttl }
3. 쿠키로 sessionId 전달
4. 이후 요청: 쿠키 -> DynamoDB 조회 -> 로그인 확인
```

**DynamoDB 선택 이유**:
- 빠른 조회 (5ms)
- TTL 자동 삭제 (만료 세션 자동 정리)
- 서버리스 (관리 쉬움)

---

## Spring (Kotlin) vs Node.js 선택 기준은?

**답변**:
프로젝트 특성에 따라 선택합니다.

**Spring vs Node.js 비교**:

| 기술 | Spring (Kotlin) | Node.js (TypeScript) |
|------|----------------|-------------------|
| **ORM** | JPA, Hibernate | TypeORM, Prisma, Sequelize |
| **쿼리 빌더** | QueryDSL, JPQL | QueryBuilder, Raw Query |
| **영속성 컨텍스트** | EntityManager (1차 캐시) | EntityManager (동일) |
| **대용량 조회** | JPQL + setMaxResults, Stream | Raw Query, QueryBuilder |
| **N+1 문제** | @EntityGraph, JOIN FETCH | relations, leftJoinAndSelect |

**선택 기준**:

| 기준 | Node.js 선택 | Spring (Kotlin) 선택 |
|------|-------------|-----------------|
| **I/O 특성** | I/O 집약적, 동시 요청 많음 | CPU 집약적, 복잡한 비즈니스 로직 |
| **성능** | 가벼움 (시작 1초, 메모리 100MB) | 무거움 (시작 10초, 메모리 500MB) |
| **트랜잭션** | 단순한 CRUD | 복잡한 트랜잭션, 정합성 중요 |
| **팀 역량** | JavaScript/TypeScript 익숙 | Java/Kotlin 익숙 |
| **사용 사례** | API 서버, 실시간 서비스, BFF | 결제, 정산, 엔터프라이즈 |

**실무 사용 사례**:
- **어드민 서버**: Node.js (I/O 집약적, 빠른 개발)
- **메인 서비스**: Spring (복잡한 비즈니스 로직, 트랜잭션)
- **배치 처리**: Spring Batch

---

## TypeORM 대량 조회 시 주의사항은?

**답변**:
TypeORM도 Spring JPA처럼 영속성 컨텍스트가 있어서 대량 조회 시 메모리 문제가 발생할 수 있습니다.

**TypeORM 영속성 컨텍스트 문제**:
```typescript
// 나쁜 예: 10만 건 조회 시 메모리 고갈
const orders = await orderRepository.find();  // 전부 영속성 컨텍스트에 로드
```

**해결 방법**:

### 1. Raw Query로 우회 (영속성 컨텍스트 사용 안 함)
```typescript
const orders = await orderRepository.query(`
  SELECT * FROM orders WHERE id > ? LIMIT 1000
`, [lastId]);
```

### 2. QueryBuilder (영속성 컨텍스트 비활성화)
```typescript
const orders = await orderRepository
  .createQueryBuilder('order')
  .where('order.id > :lastId', { lastId })
  .limit(1000)
  .getMany();
```

### 3. Cursor 페이지네이션 (성능)
```typescript
// Offset: 10만 번째 페이지 (5초)
SELECT * FROM orders LIMIT 100 OFFSET 100000;

// Cursor: 일정한 성능 (0.01초)
SELECT * FROM orders WHERE id > 100000 ORDER BY id LIMIT 100;
```

**Spring 경험자라면**:
> "Spring에서는 JPA 영속성 컨텍스트 때문에 대량 조회 시 메모리 문제가 있어서 JPQL이나 QueryDSL로 해결했습니다. Node.js의 TypeORM도 동일한 문제가 있어서 Raw Query나 QueryBuilder를 사용합니다. 차이점은 Spring은 QueryDSL이 타입 안전하지만, TypeORM은 Raw Query를 많이 씁니다."

---

## 면접 핵심 요약

| 질문 | 핵심 답변 |
|------|---------|
| **싱글 스레드인데 동시 처리?** | Event Loop + Non-blocking I/O (OS에 I/O 위임) |
| **DB는 워커 스레드 사용?** | 아니오. OS 비동기 I/O 사용 (CPU 안 씀) |
| **Promise는 항상 비동기?** | 아니오. 생성자는 동기, .then()만 비동기 |
| **await은 블로킹?** | 아니오. 함수만 멈춤, 메인 스레드 계속 진행 |
| **Microtask vs Macrotask?** | Microtask(Promise) 먼저 -> Macrotask(setTimeout) 나중 |
| **Promise.all 쓰는 이유?** | 병렬 실행으로 속도 향상 (6초 -> 3초) |
| **CPU 작업은?** | Cluster (PM2) 또는 외부 서비스 분리 |
| **트랜잭션은?** | All or Nothing 보장 (주문+재고) |
| **동시성 제어는?** | DB Atomic 연산 (단일), Redis Lock (분산) |
| **SSO 인증은?** | OAuth 2.0 (구글) + DynamoDB 세션 저장 + TTL 자동 삭제 |
| **Java vs Node.js?** | I/O 많으면 Node.js, CPU 많으면 Java |

---

## 실전 답변 예시

### "왜 Node.js를 선택했나요?"
저희 프로젝트는 여러 API를 조합하는 I/O 집약적 작업이 많아서 Node.js를 선택했습니다. Promise.all로 병렬 처리가 간편했고, TypeScript로 프론트와 타입을 공유하면서 개발 속도도 빨랐습니다. 다만 CPU 작업은 약하기 때문에, 무거운 계산은 Cluster나 외부 서비스로 분리했습니다.

### "Node.js 성능 최적화 경험은?"
Promise.all로 병렬 처리해서 API 응답 시간을 6초에서 3초로 50% 단축했습니다. 자주 조회하는 데이터는 Redis 캐싱으로 DB 부하를 70% 줄였고, PM2 Cluster 모드로 트래픽 처리량을 4배 늘렸습니다.

### "재고 관리 시스템 설계는?"
동시성 제어가 핵심입니다. 단일 서버면 DB Atomic 연산(`UPDATE stock = stock - 1 WHERE stock > 0`)이 가장 간단하고, MSA 환경이면 Redis 분산 락을 사용합니다. 주문 생성과 재고 차감은 트랜잭션으로 묶어서 데이터 일관성을 보장합니다.

### "대용량 트래픽 처리 경험은?"
서버는 PM2 Cluster와 Nginx 로드밸런서로 분산했고, DB는 Connection Pool 튜닝과 Read Replica로 읽기/쓰기를 분리했습니다. 자주 조회하는 데이터는 Redis로 캐싱하고, 무거운 작업은 Message Queue로 백그라운드 처리했습니다.

### "에러 처리는?"
async/await에서 try-catch로 에러를 잡고, Express Global Error Handler로 예상치 못한 에러를 캐치합니다. uncaughtException 발생 시 로깅 후 프로세스를 재시작하고, Sentry로 실시간 에러를 추적하며 Slack 알림을 받습니다.

### "Node.js vs Spring Boot 선택 기준은?"
I/O 작업이 많고 빠른 개발이 필요하면 Node.js, CPU 집약적이고 복잡한 트랜잭션이 많으면 Spring Boot를 선택합니다. 실무에서는 MSA로 각 서비스 특성에 맞게 선택합니다. (API 서버는 Node.js, 배치는 Spring)

### "SSO 인증 구현 경험은?"
어드민 서버에서 구글 SSO를 구현했습니다. OAuth 2.0 프로토콜로 구글에서 사용자 정보를 받아오고, 세션은 DynamoDB에 저장했습니다. DynamoDB의 TTL 기능으로 만료된 세션을 자동 삭제해서 관리 포인트를 줄였고, 빠른 조회 속도(5ms)로 매 요청마다 인증 확인이 가능했습니다. 비밀번호를 직접 관리하지 않아도 돼서 보안 부담도 줄었습니다.

---

## 면접 전 핵심 체크리스트

- **await은 블로킹 아님** -> 함수만 멈춤, 메인 스레드 계속
- **Promise 생성자는 동기**, `.then()`은 비동기
- **DB는 워커 안 씀** -> OS 비동기 I/O (네트워크)
- **재고 차감** -> DB Atomic 연산 또는 SELECT FOR UPDATE
- **CPU 작업** -> Cluster/Worker/외부 서비스 분리
- **Promise.all** -> 병렬 처리로 속도 향상
- **Microtask > Macrotask** -> Promise가 setTimeout보다 빠름
- **Event Loop** -> Call Stack 비면 Microtask -> Task Queue 순서
- **SSO** -> OAuth 2.0 (구글) + DynamoDB 세션 (TTL 자동 삭제)

**면접 팁**: 실무 경험처럼 답변하고, 숫자로 말하기 (50% 감소, 4배 증가)

### 동적 프로그래밍 VS 분할 정복

| 구분 | 동적 프로그래밍                                                                                                                                                                                                        | 분할 정복                                                                                                                     |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| 정의 | 중복되는 하위 문제들의 해답을 저장하고 재활용하여, 전체 문제의 해결 방법을 찾아내는 알고리즘 디자인 기법                                                                                                               | 문제를 더 작은 문제로 분할하고, 각각을 해결한 뒤, 그 해결 방법을 합쳐서 전체 문제의 해결 방법을 찾아내는 알고리즘 디자인 기법 |
| 특징 | - 메모이제이션 또는 하향식 접근 방법을 사용.<br>- 동적 계획법은 중복 계산을 피하기 위해 결과를 저장. 새로운 부분 문제의 정답을 다른 부분 문제의 정답으로부터 구함<br>- 피보나치 수열, 최장 공통 부분 문자열 등에 사용. | - 분할 정복은 대개 재귀적으로 문제를 해결.<br>- 병합 정렬, 퀵 정렬, 이진 검색 등에 사용.<br>- 각 부분 문제는 서로 독립적      |

---

### Big O 표기법

- 알고리즘의 시간 복잡도나 공간 복잡도를 나타내는 표기법으로, 알고리즘의 최악의 경우를 나타냄

---

### 선택 정렬

- 주어진 배열 중에서 최솟값을 찾아 맨 앞에 값과 교체.
- 맨 처음 위치를 뺀 나머지 리스트들을 같은 방법으로 교체
- 시간복잡도 O(N^2)

```java
 public int[] mySolution(int N, int[] arr) {
        for (int i = 0; i < N - 1; i++) {
            int cur = arr[i];
            int min = cur;
            int minIdx = 0;
            for (int j = i + 1; j < N; j++) {
                if (arr[j] < min) {
                    min = arr[j];
                    minIdx = j;
                }
            }
            if (minIdx != 0) {
                arr[i] = min;
                arr[minIdx] = cur;
            }
        }
        return arr;
    }
```

---

### 버블 정렬

- 서로 인접한 두 원소를 비교하여 정렬. 0번부터 n-1번 인덱스까지 n번까지의 모든 인덱스 비교하며 정렬
- 한번 회전할 때마다 맨 마지막에 가장 큰 원소가 오게 된다 (뒤에서부터 채워진다)
- 시간복잡도 O(N^2)

```java
    public int[] mySolution(int N, int[] arr) {
        for (int j = N - 1; j > 0; j--) {
            for (int i = 0; i < j; i++) {
                if (arr[i] > arr[i + 1]) {
                    int tmp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = tmp;
                }
            }
        }
        return arr;
    }
```

---

### 힙 정렬

- 주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최솟값부터 하나씩 꺼내서 정렬
- 전체 정렬보다는 가장 큰 값(또는 가장 작은 값) 몇 개만을 필요로 할 때 유용
- 시간복잡도 O(NlogN)

---

### 머지 정렬

- 주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할/정복 알고리즘
- 시간 복잡도 O(NlogN)

---

### 퀵 정렬

- 리스트를 비균등하게 분할
- 피봇을 설정하고, 피봇보다 큰 값과 작은 값으로 분할하여 정렬
- 시간 복잡도 O(NLogN)이지만 리스트가 계속 불균등하게 나누어질 경우 O(N^2)까지 나빠질 수 있음

---

### 삽입 정렬

- 두번째 값부터 시작하여 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘
- 평균 시간 복잡도 O(N^2)이지만 가장 빠를 경우 O(N)

```java
    public int[] mySolution(int N, int[] arr) {
        for (int i = 1; i < N; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[i] < arr[j]) {
                    int tmp = arr[i];
                    for (int k = i; k > j; k--) {
                        arr[k] = arr[k - 1];
                    }
                    arr[j] = tmp;
                    break;
                }
            }
        }
        return arr;
    }
```

---

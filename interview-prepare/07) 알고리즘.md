# 알고리즘

### 선택 정렬

- 주어진 배열 중에서 최솟값을 찾아 맨 앞에 값과 교체.
- 맨 처음 위치를 뺀 나머지 리스트들을 같은 방법으로 교체
- 시간복잡도 O(N^2)

```java
 public int[] mySolution(int N, int[] arr) {
        for (int i = 0; i < N - 1; i++) {
            int cur = arr[i];
            int min = cur;
            int minIdx = 0;
            for (int j = i + 1; j < N; j++) {
                if (arr[j] < min) {
                    min = arr[j];
                    minIdx = j;
                }
            }
            if (minIdx != 0) {
                arr[i] = min;
                arr[minIdx] = cur;
            }
        }
        return arr;
    }
```

---

### 버블 정렬

- 서로 인접한 두 원소를 비교하여 정렬. 0번부터 n-1번 인덱스까지 n번까지의 모든 인덱스 비교하며 정렬
- 한번 회전할 때마다 맨 마지막에 가장 큰 원소가 오게 된다 (뒤에서부터 채워진다)
- 시간복잡도 O(N^2)

```java
    public int[] mySolution(int N, int[] arr) {
        for (int j = N - 1; j > 0; j--) {
            for (int i = 0; i < j; i++) {
                if (arr[i] > arr[i + 1]) {
                    int tmp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = tmp;
                }
            }
        }
        return arr;
    }
```

---

### 힙 정렬

- 주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최솟값부터 하나씩 꺼내서 정렬
- 전체 정렬보다는 가장 큰 값(또는 가장 작은 값) 몇 개만을 필요로 할 때 유용
- 시간복잡도 O(NlogN)

---

### 머지 정렬

- 주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할/정복 알고리즘
- 시간 복잡도 O(NlogN)

---

### 퀵 정렬

- 리스트를 비균등하게 분할
- 피봇을 설정하고, 피봇보다 큰 값과 작은 값으로 분할하여 정렬
- 시간 복잡도 O(NLogN)이지만 리스트가 계속 불균등하게 나누어질 경우 O(N^2)까지 나빠질 수 있음

---

### 삽입 정렬

- 두번째 값부터 시작하여 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘
- 평균 시간 복잡도 O(N^2)이지만 가장 빠를 경우 O(N)

---

### 동적 프로그래밍 (Dynamic Programming)

- 주어진 문제를 풀기 위해서 문제를 여러 개의 하위 문제로 나누어 푼 다음, 그것을 결합하여 해결하는 방식
- 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 답을 여러 번 계산하는 대신 한 번만 계산하고 그 결과를 재활용하는 메모이제이션(Memoiztion) 기법으로 속도 향상
- Overlapping Subproblem: 주어진 문제는 같은 부분 문제가 여러번 재사용
- Optimal Structure: 새로운 부분 문제의 정답을 다른 부분 문제의 정답으로부터 구함

---

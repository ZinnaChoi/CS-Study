### 동적 프로그래밍 VS 분할 정복

| 구분 | 동적 프로그래밍                                                                                                                                                                                                        | 분할 정복                                                                                                                     |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| 정의 | 중복되는 하위 문제들의 해답을 저장하고 재활용하여, 전체 문제의 해결 방법을 찾아내는 알고리즘 디자인 기법                                                                                                               | 문제를 더 작은 문제로 분할하고, 각각을 해결한 뒤, 그 해결 방법을 합쳐서 전체 문제의 해결 방법을 찾아내는 알고리즘 디자인 기법 |
| 특징 | - 메모이제이션 또는 하향식 접근 방법을 사용.<br>- 동적 계획법은 중복 계산을 피하기 위해 결과를 저장. 새로운 부분 문제의 정답을 다른 부분 문제의 정답으로부터 구함<br>- 피보나치 수열, 최장 공통 부분 문자열 등에 사용. | - 분할 정복은 대개 재귀적으로 문제를 해결.<br>- 병합 정렬, 퀵 정렬, 이진 검색 등에 사용.<br>- 각 부분 문제는 서로 독립적      |

---

### Big O 표기법

- 알고리즘의 시간 복잡도나 공간 복잡도를 나타내는 표기법으로, 알고리즘의 최악의 경우를 나타냄

---

### 재귀

| 구분 | 설명                                                                                                                                                                                                            |
| ---- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 정의 | 함수가 직접적으로 또는 간접적으로 자기 자신을 호출하는 프로세스                                                                                                                                                 |
| 특징 | - 재귀는 복잡한 문제를 간단하게 분해하여 해결.<br>- 기저 조건(Base Case)을 정의하여 재귀 호출이 종료되도록 해야 함<br>- 스택 오버플로우를 방지하기 위해 재귀의 깊이에 주의.<br>- 반복문보다 메모리를 많이 사용. |

---

### BFS, 너비 우선 탐색

| 구분 | 설명                                                                                                                                                                                              |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 정의 | 그래프의 모든 노드를 체계적으로 탐색하는 방법으로, 가장 가까운 노드부터 차례대로 탐색                                                                                                             |
| 특징 | - 너비 우선으로 탐색하여 단계별로 이동.<br>- 최단 경로 문제에 자주 사용.<br>- 큐(Queue)를 사용하여 구현.<br>- 모든 노드를 방문하므로 탐색에 걸리는 시간은 O(V + E)(V는 노드의 수, E는 간선의 수). |

---

### DFS, 깊이 우선 탐색

| 구분 | 설명                                                                                                                                                                                                                                                       |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 정의 | 그래프의 모든 노드를 체계적으로 탐색하는 방법으로, 한 방향으로 깊게 탐색하다가 더 이상 탐색할 수 없으면 이전 분기점으로 돌아와 다른 방향으로 탐색을 계속하는 방식                                                                                          |
| 특징 | - 깊이 우선으로 탐색하여 가능한 한 멀리 있는 노드를 우선적으로 탐색.<br>- 백트래킹과 함께 사용될 때 효과적.<br>- 스택(Stack) 또는 재귀(Recursion)를 사용하여 구현<br>- 모든 노드를 방문하므로 탐색에 걸리는 시간은 O(V + E)(V는 노드의 수, E는 간선의 수). |

---

### 선택 정렬

- 주어진 배열 중에서 최솟값을 찾아 맨 앞에 값과 교체.
- 맨 처음 위치를 뺀 나머지 리스트들을 같은 방법으로 교체
- 시간복잡도 O(N^2)

```java
 public int[] mySolution(int N, int[] arr) {
        for (int i = 0; i < N - 1; i++) {
            int cur = arr[i];
            int min = cur;
            int minIdx = 0;
            for (int j = i + 1; j < N; j++) {
                if (arr[j] < min) {
                    min = arr[j];
                    minIdx = j;
                }
            }
            if (minIdx != 0) {
                arr[i] = min;
                arr[minIdx] = cur;
            }
        }
        return arr;
    }
```

---

### 버블 정렬

- 서로 인접한 두 원소를 비교하여 정렬. 0번부터 n-1번 인덱스까지 n번까지의 모든 인덱스 비교하며 정렬
- 한번 회전할 때마다 맨 마지막에 가장 큰 원소가 오게 된다 (뒤에서부터 채워진다)
- 시간복잡도 O(N^2)

```java
    public int[] mySolution(int N, int[] arr) {
        for (int j = N - 1; j > 0; j--) {
            for (int i = 0; i < j; i++) {
                if (arr[i] > arr[i + 1]) {
                    int tmp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = tmp;
                }
            }
        }
        return arr;
    }
```

---

### 힙 정렬

- 주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최솟값부터 하나씩 꺼내서 정렬
- 전체 정렬보다는 가장 큰 값(또는 가장 작은 값) 몇 개만을 필요로 할 때 유용
- 시간복잡도 O(NlogN)

---

### 머지 정렬

| 구분 | 설명                                                                                                                                                             |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 정의 | 배열을 반으로 나누고, 각각을 재귀적으로 정렬한 다음, 두 배열을 합치는 분할 정복 알고리즘입니다.                                                                  |
| 특징 | - 항상 O(n log n)의 시간 복잡도를 가짐.<br>- 안정적인 정렬 방법.<br>- 대규모 데이터셋에 대해 일관된 성능.<br>- 추가 메모리가 필요한 외부 정렬(Out-of-place sort) |

---

### 퀵 정렬

| 구분 | 설명                                                                                                                                                                                       |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 정의 | 피벗을 기준으로 배열을 분할하고, 각 부분 배열을 재귀적으로 정렬하는 분할 정복 알고리즘                                                                                                     |
| 특징 | - 평균적으로 O(n log n)의 시간 복잡도.<br>- 최악의 경우 O(n^2)의 시간 복잡도(피벗 선택에 따라 달라짐).<br>- 대규모 데이터셋에 대해 높은 성능.<br>- 제자리 정렬(In-place sorting) 알고리즘. |

---

### 삽입 정렬

- 두번째 값부터 시작하여 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘
- 평균 시간 복잡도 O(N^2)이지만 가장 빠를 경우 O(N)

```java
    public int[] mySolution(int N, int[] arr) {
        for (int i = 1; i < N; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[i] < arr[j]) {
                    int tmp = arr[i];
                    for (int k = i; k > j; k--) {
                        arr[k] = arr[k - 1];
                    }
                    arr[j] = tmp;
                    break;
                }
            }
        }
        return arr;
    }
```

---

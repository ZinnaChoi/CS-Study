### 동적 프로그래밍 (Dynamic Programming, DP)

| 구분        | 설명                                                                                                                                                            |
| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 정의        | - 중복되는 하위 문제들의 해답을 저장해두고 재사용함으로써 복잡한 문제를 효율적으로 해결하는 방법                                                                |
| 특징        | - 큰 문제를 작은 문제로 나누어 해결 (분할 정복과 유사)<br>- 하위 문제의 해답을 저장하고 재사용 (메모이제이션 또는 타뷸레이션 기법 사용)<br>- 중복 계산을 최소화 |
| 적용 사례   | - 피보나치 수열<br>- 최장 증가 부분 수열(Longest Increasing Subsequence)<br>- 0/1 배낭 문제(Knapsack Problem)<br>- 동전 교환 문제                               |
| 시간 복잡도 | - 문제에 따라 다르지만, 중복 계산을 피함으로써 일반적인 재귀보다 훨씬 빠름                                                                                      |

---

### 분할 정복 (Divide and Conquer)

| 구분        | 설명                                                                                                                                  |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| 정의        | - 문제를 더 작은 문제로 분할하고, 각각을 해결한 다음 그 해결 방법을 합쳐서 전체 문제의 해결 방법을 찾아내는 알고리즘 디자인 기법      |
| 특징        | - 재귀적 접근 방법을 사용<br>- 하위 문제는 서로 독립적이며, 이들을 합쳐서 전체 문제 해결<br>- 병합 정렬, 퀵 정렬, 이진 검색 등에 사용 |
| 적용 사례   | - 병합 정렬(Merge Sort)<br>- 퀵 정렬(Quick Sort)<br>- 이진 검색(Binary Search)<br>- 최근접 점의 쌍 문제(Closest Pair of Points)       |
| 시간 복잡도 | - O(n log n) (병합 정렬과 퀵 정렬의 경우)                                                                                             |

---

### 이진 탐색 알고리즘

| 구분      | 설명                                                                                                |
| --------- | --------------------------------------------------------------------------------------------------- |
| 정의      | - 정렬된 배열에서 탐색 범위를 반으로 줄여가며 데이터를 찾는 알고리즘                                |
| 특징      | - 탐색 범위를 절반씩 줄여나가므로, 탐색 속도가 매우 빠름<br>- O(log n)의 시간 복잡도                |
| 사용 사례 | - 정렬된 데이터 내에서 특정 값을 찾아야 할 때<br>- 라이브러리 함수에서 데이터 검색 기능에 널리 사용 |

---

### 그리디 알고리즘

| 구분      | 설명                                                                                                  |
| --------- | ----------------------------------------------------------------------------------------------------- |
| 정의      | - 매 순간 최적이라고 생각되는 경우를 선택해 나가는 방식으로 최종적인 해답을 찾는 알고리즘             |
| 특징      | - 각 단계에서의 최적의 선택이 전체에서도 최적임을 보장해야 함<br>- O(n) 또는 O(n log n)의 시간 복잡도 |
| 사용 사례 | - 최소 신장 트리: 프림 알고리즘, 크루스칼 알고리즘<br>- 단기 최적해를 구하는 다양한 문제              |

---

### 백트래킹

| 구분        | 설명                                                                                                                       |
| ----------- | -------------------------------------------------------------------------------------------------------------------------- |
| 정의        | - 모든 가능한 경우의 수 중에서 해를 찾는 알고리즘. 해가 될 가능성이 없다고 판단되는 즉시 더 이상 탐색하지 않고 뒤로 돌아감 |
| 특징        | - 모든 경우의 수를 탐색하지만, 비효율적인 경로는 조기에 차단<br>- 문제의 해를 찾기까지 시도해보는 모든 경로를 탐색         |
| 적용 사례   | - N-Queen 문제<br>- 스도쿠<br>- 순열 검색<br>- 조합의 모든 경우의 수 탐색                                                  |
| 시간 복잡도 | - 문제와 해법에 따라 다르며, 최악의 경우 지수 시간 복잡도를 가질 수 있음                                                   |

---

### Big O 표기법

- 알고리즘의 시간 복잡도나 공간 복잡도를 나타내는 표기법으로, 알고리즘의 최악의 경우를 나타냄

---

### 재귀

| 구분 | 설명                                                                                                                                                                                                            |
| ---- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 정의 | 함수가 직접적으로 또는 간접적으로 자기 자신을 호출하는 프로세스                                                                                                                                                 |
| 특징 | - 재귀는 복잡한 문제를 간단하게 분해하여 해결.<br>- 기저 조건(Base Case)을 정의하여 재귀 호출이 종료되도록 해야 함<br>- 스택 오버플로우를 방지하기 위해 재귀의 깊이에 주의.<br>- 반복문보다 메모리를 많이 사용. |

---

### BFS, 너비 우선 탐색

| 구분 | 설명                                                                                                                                                                                              |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 정의 | 그래프의 모든 노드를 체계적으로 탐색하는 방법으로, 가장 가까운 노드부터 차례대로 탐색                                                                                                             |
| 특징 | - 너비 우선으로 탐색하여 단계별로 이동.<br>- 최단 경로 문제에 자주 사용.<br>- 큐(Queue)를 사용하여 구현.<br>- 모든 노드를 방문하므로 탐색에 걸리는 시간은 O(V + E)(V는 노드의 수, E는 간선의 수). |

---

### DFS, 깊이 우선 탐색

| 구분 | 설명                                                                                                                                                                                                                                                       |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 정의 | 그래프의 모든 노드를 체계적으로 탐색하는 방법으로, 한 방향으로 깊게 탐색하다가 더 이상 탐색할 수 없으면 이전 분기점으로 돌아와 다른 방향으로 탐색을 계속하는 방식                                                                                          |
| 특징 | - 깊이 우선으로 탐색하여 가능한 한 멀리 있는 노드를 우선적으로 탐색.<br>- 백트래킹과 함께 사용될 때 효과적.<br>- 스택(Stack) 또는 재귀(Recursion)를 사용하여 구현<br>- 모든 노드를 방문하므로 탐색에 걸리는 시간은 O(V + E)(V는 노드의 수, E는 간선의 수). |

---

### 선택 정렬

- 주어진 배열 중에서 최솟값을 찾아 맨 앞에 값과 교체.
- 맨 처음 위치를 뺀 나머지 리스트들을 같은 방법으로 교체
- 시간복잡도 O(N^2)

```java
 public int[] mySolution(int N, int[] arr) {
        for (int i = 0; i < N - 1; i++) {
            int cur = arr[i];
            int min = cur;
            int minIdx = 0;
            for (int j = i + 1; j < N; j++) {
                if (arr[j] < min) {
                    min = arr[j];
                    minIdx = j;
                }
            }
            if (minIdx != 0) {
                arr[i] = min;
                arr[minIdx] = cur;
            }
        }
        return arr;
    }
```

---

### 버블 정렬

- 서로 인접한 두 원소를 비교하여 정렬. 0번부터 n-1번 인덱스까지 n번까지의 모든 인덱스 비교하며 정렬
- 한번 회전할 때마다 맨 마지막에 가장 큰 원소가 오게 된다 (뒤에서부터 채워진다)
- 시간복잡도 O(N^2)

```java
    public int[] mySolution(int N, int[] arr) {
        for (int j = N - 1; j > 0; j--) {
            for (int i = 0; i < j; i++) {
                if (arr[i] > arr[i + 1]) {
                    int tmp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = tmp;
                }
            }
        }
        return arr;
    }
```

---

### 힙 정렬

- 주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최솟값부터 하나씩 꺼내서 정렬
- 전체 정렬보다는 가장 큰 값(또는 가장 작은 값) 몇 개만을 필요로 할 때 유용
- 시간복잡도 O(NlogN)

---

### 머지 정렬

| 구분 | 설명                                                                                                                                                             |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 정의 | 배열을 반으로 나누고, 각각을 재귀적으로 정렬한 다음, 두 배열을 합치는 분할 정복 알고리즘입니다.                                                                  |
| 특징 | - 항상 O(n log n)의 시간 복잡도를 가짐.<br>- 안정적인 정렬 방법.<br>- 대규모 데이터셋에 대해 일관된 성능.<br>- 추가 메모리가 필요한 외부 정렬(Out-of-place sort) |

---

### 퀵 정렬

| 구분 | 설명                                                                                                                                                                                       |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 정의 | 피벗을 기준으로 배열을 분할하고, 각 부분 배열을 재귀적으로 정렬하는 분할 정복 알고리즘                                                                                                     |
| 특징 | - 평균적으로 O(n log n)의 시간 복잡도.<br>- 최악의 경우 O(n^2)의 시간 복잡도(피벗 선택에 따라 달라짐).<br>- 대규모 데이터셋에 대해 높은 성능.<br>- 제자리 정렬(In-place sorting) 알고리즘. |

---

### 삽입 정렬

- 두번째 값부터 시작하여 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘
- 평균 시간 복잡도 O(N^2)이지만 가장 빠를 경우 O(N)

```java
    public int[] mySolution(int N, int[] arr) {
        for (int i = 1; i < N; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[i] < arr[j]) {
                    int tmp = arr[i];
                    for (int k = i; k > j; k--) {
                        arr[k] = arr[k - 1];
                    }
                    arr[j] = tmp;
                    break;
                }
            }
        }
        return arr;
    }
```

---

### CI/CD (지속적 통합/지속적 배포)

| 구분             | 설명                                                                                                                      |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------- |
| CI (지속적 통합) | 개발자가 작업한 코드를 주기적으로 메인에 병합하여 자동으로 빌드와 테스트를 수행함으로써 소프트웨어의 품질을 유지하는 과정 |
| CD (지속적 배포) | CI 과정을 통과한 코드를 자동으로 운영 환경에 배포하여 사용자에게 제공하는 과정                                            |

---

### 도커 VS VM

| 구분 | 도커                                                                                                                     | VM                                                                                                              |
| ---- | ------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------- |
| 정의 | 컨테이너화된 애플리케이션을 생성, 배포, 실행하기 위한 오픈 소스 플랫폼                                                   | 완전히 독립된 가상 환경을 제공하며 자체 OS를 실행할 수 있는 기술                                                |
| 특징 | - 애플리케이션과 그 의존성을 컨테이너 안에 패키징<br>- 환경에 구애받지 않고 실행 가능<br>- 시스템 자원을 효율적으로 사용 | - 각 가상 머신은 완전한 게스트 OS를 포함<br>- 다양한 OS 환경을 하나의 서버에서 실행 가능                        |
| 이점 | - 배포의 효율성과 이식성 향상<br>- VM보다 빠르고 효율적인 리소스 사용(호스트 OS의 커널 공유)가능                         | - 각 가상 머신은 독립적으로 실행되며, 자원 할당에 있어 무겁고 느릴 수 있음에도 불구하고 완전히 격리된 환경 제공 |

### Docker 핵심 개념

| 개념 | 설명 |
|------|------|
| **이미지** | 컨테이너 실행에 필요한 파일과 설정값을 포함한 템플릿 |
| **컨테이너** | 이미지를 실행한 상태, 애플리케이션의 격리된 실행 환경 |
| **Dockerfile** | 이미지 생성을 위한 스크립트 파일 |
| **레지스트리** | 이미지를 저장하고 공유하는 저장소 (Docker Hub, ECR 등) |
| **볼륨** | 데이터 영구 저장을 위한 메커니즘 |
| **네트워크** | 컨테이너 간 통신을 위한 가상 네트워크 |

---

### 쿠버네티스

| 개념 | 설명 |
| ---- | --------------------------------------------------------------------------- |
| 정의 | 도커를 통해 구동되는 컨테이너를 관리하는 시스템. 컨테이너 오케스트레이션 툴 |
| 기능 | 컨테이너화된 애플리케이션의 배포, 확장 및 관리를 자동화                     |

#### 쿠버네티스 핵심 구성요소

| 구성요소 | 설명 |
|----------|------|
| **Pod** | 가장 작은 배포 단위, 하나 이상의 컨테이너를 포함 |
| **Service** | Pod들에 대한 네트워크 접근을 제공하는 추상화 |
| **Deployment** | Pod의 생성과 관리를 담당하는 컨트롤러 |
| **ConfigMap** | 설정 데이터를 저장하는 오브젝트 |
| **Secret** | 민감한 정보(비밀번호, 토큰)를 저장 |
| **Ingress** | 외부에서 클러스터 내부로의 HTTP/HTTPS 라우팅 |

### AWS 핵심 서비스

| 서비스 | 설명 |
|--------|------|
| **EC2** | 가상 서버 인스턴스 제공 |
| **RDS** | 관리형 관계형 데이터베이스 서비스 |
| **S3** | 객체 스토리지 서비스 |
| **Lambda** | 서버리스 컴퓨팅 서비스 |
| **ELB** | 로드 밸런서 서비스 |
| **CloudWatch** | 모니터링 및 관찰 서비스 |
| **VPC** | 가상 사설 클라우드 |
| **IAM** | 권한 및 액세스 관리 |

### 마이크로서비스 아키텍처

| 개념 | 설명 |
|------|------|
| **정의** | 애플리케이션을 작고 독립적인 서비스들로 분해하는 아키텍처 패턴 |
| **장점** | - 독립적 배포<br>- 기술 스택 다양성<br>- 장애 격리<br>- 확장성 |
| **단점** | - 분산 시스템 복잡성<br>- 네트워크 지연<br>- 데이터 일관성 문제 |
| **패턴** | - API Gateway<br>- Service Discovery<br>- Circuit Breaker<br>- CQRS |

---

### 컨테이너화가 중요한 이유

- 애플리케이션을 격리된 환경에서 실행 가능
- 배포, 확장성과, 이식성 개선
- 환경에 구애받지 않는 일관된 실행 환경 제공

---

### 컨테이너 오케스트레이션

- 컨테이너 배포, 관리, 확장, 네트워킹을 자동화하는 프로세스로 쿠버네티스 와 같은 도구를 사용
- 대규모의 컨테이너화된 애플리케이션을 효율적으로 관리

---

### APM (Application Performance Monitoring)

#### 목적 및 주요 도구
- **목적**: 애플리케이션 성능 및 장애 모니터링
- **주요 도구**:
  - **제니퍼**: 국산 APM 솔루션
  - **스카우터**: 오픈소스 APM
  - **X-Log**: 성능 로그 분석

#### 모니터링 대상
- DB 응답 시간
- JVM 상태 (메모리, GC)
- 트랜잭션 성능
- 에러율 및 처리량

---

### Kafka

#### 핵심 개념

**Kafka란?**
- **정의**: 대규모 데이터를 처리할 수 있는 분산 메시지 스트리밍 플랫폼
- **역할**: 비동기적으로 데이터를 처리하는 메시지 큐 시스템
- **특징**: 높은 처리량, 실시간 데이터 처리, 데이터 영속성 보장

**메시지 큐의 장점**
- **비동기 처리**: 프로듀서와 컨슈머의 속도 차이 해결
- **시스템 분리**: 서비스 간 느슨한 결합
- **확장성**: 독립적인 확장 가능
- **내결함성**: 메시지 손실 방지

#### Kafka 아키텍처

**기본 구성 요소**
- **Producer**: 메시지를 생산하여 토픽에 전달하는 주체
- **Consumer**: 토픽에서 메시지를 가져와 처리하는 주체
- **Topic**: 메시지를 구분하는 카테고리
- **Broker**: 메시지를 저장하고 클라이언트 요청을 처리 (포트 9092)
- **Controller**: 클러스터 상태를 관리하는 특별한 브로커 (포트 9093)

**Partition (파티션)**
- **정의**: 토픽을 여러 개로 나눠 병렬 처리를 가능하게 하는 단위
- **특징**:
  - 각 토픽은 1개 이상의 파티션으로 구성
  - 파티션 내에서만 메시지 순서 보장
  - 하나의 파티션은 하나의 컨슈머에게만 할당 (동일 그룹 내)
  - 파티션 수는 늘릴 수만 있고 줄일 수 없음

#### Consumer Group & Offset

**Consumer Group**
- **정의**: 하나 이상의 컨슈머로 구성된 그룹
- **목적**: 메시지 중복 처리 방지 및 처리 상태 관리
- **특징**: 그룹 단위로 오프셋 관리

**Offset**
- **정의**: 컨슈머 그룹이 어디까지 메시지를 읽었는지 기록하는 번호
- **특징**:
  - 0부터 시작
  - 컨슈머 그룹 단위로 관리
  - current-offset = 다음에 읽을 메시지 번호

#### 고가용성 (High Availability)

**클러스터 구성**
- **Node**: Kafka가 설치된 서버 단위
- **Cluster**: 여러 노드가 하나의 시스템처럼 동작
- **최소 구성**: 3대 이상의 노드 권장

**Replication (복제)**
- **목적**: 데이터 안정성과 가용성 보장
- **구성**:
  - **Leader Partition**: 읽기/쓰기 담당 (원본)
  - **Follower Partition**: Leader 복제본, 장애 시 승격
  - **ISR (In-Sync Replica)**: 완전히 동기화된 복제본 집합

**메시지 처리 확인 방식**
- **acks=0**: 확인 없이 전송 (Fire and Forget)
- **acks=1**: Leader 파티션만 확인
- **acks=-1/all**: 모든 ISR 확인 (가장 안전)

#### 장애 처리 전략

**Retry (재시도)**
```java
@RetryableTopic(
    attempts = "5",  // 최초 시도 포함 5번
    backoff = @Backoff(delay = 1000, multiplier = 2),  // 지수 백오프
    dltTopicSuffix = ".dlt"
)
```

**DLT (Dead Letter Topic)**
- **정의**: 재시도 실패한 메시지를 보관하는 특별한 토픽
- **특징**:
  - 원본 메시지는 유지됨
  - 실패 메시지의 복사본 1개만 저장
  - 토픽 단위로 자동 생성 (email.send → email.send.dlt)

#### 면접 예상 질문

**Q1. Kafka를 사용하는 이유는?**
- 대용량 실시간 데이터 처리
- 시스템 간 비동기 통신
- 메시지 영속성과 재처리 가능

**Q2. 파티션과 컨슈머 그룹의 관계는?**
- 하나의 파티션은 그룹 내 하나의 컨슈머만 처리
- 파티션 수 ≥ 컨슈머 수가 이상적

**Q3. 메시지 순서 보장은 어떻게?**
- 파티션 단위로만 순서 보장
- 같은 키 사용하여 같은 파티션으로 라우팅

**Q4. 장애 발생 시 데이터 손실을 방지하려면?**
- Replication Factor 설정 (2-3)
- acks=all 설정
- min.insync.replicas 설정

**Q5. Kafka vs RabbitMQ 선택 기준은?**

| 요구사항 | Kafka | RabbitMQ |
|---------|-------|----------|
| **메시지 재처리** | Offset 조정으로 재처리 | 읽으면 삭제됨 |
| **처리량** | 초당 수만~수십만 TPS | 상대적으로 낮음 |
| **메시지 순서** | 파티션 단위 보장 | 큐 단위만 보장 |
| **메시지 영속성** | 설정 기간 동안 보관 | 읽으면 삭제 |
| **라우팅** | 단순 Pub/Sub | Exchange 기반 유연한 라우팅 |

**선택 기준**: 높은 처리량 + 메시지 재처리가 필요하면 Kafka, 복잡한 라우팅이 필요하면 RabbitMQ

---

### 메세지 큐(Message Queue)

|      | 메시지 큐(Message Queue)                                               |
| ---- | ---------------------------------------------------------------------- |
| 정의 | Queue 자료구조를 이용하여 데이터를 관리하는 시스템                     |
| 기능 | - 비동기 통신 프로토콜 제공<br>- 메세지를 빠르게 주고받을 수 있게 해줌 |

---

### 온프레미스 → 클라우드 전환

#### 클라우드 장점
- **확장성**: 트래픽 증가 시 자동 스케일링
- **비용 효율성**: 사용한 만큼만 과금, 초기 투자비용 절약
- **가용성**: 멀티 리전, 자동 백업/복구
- **관리 편의성**: 인프라 관리 부담 감소

#### 클라우드 단점
- **보안 우려**: 데이터 외부 저장, 클라우드 업체 의존
- **네트워크 의존성**: 인터넷 연결 필수, 지연 시간
- **벤더 락인**: 특정 클라우드 업체 종속성
- **컴플라이언스**: 규제 요구사항 충족 어려움

#### 전환 시 고려사항
- 데이터 마이그레이션 계획 (다운타임 최소화)
- 보안 정책 재수립
- TCO(Total Cost of Ownership) 계산
- 직원 교육

---

### 부하분산

#### L4 스위치
- IP/포트 기반 부하분산
- 세션 지속성 제공
- 헬스체크 기능
- **알고리즘**: Round Robin, Least Connection, Weighted

#### GSLB (Global Server Load Balancing)
- DNS 기반 글로벌 부하분산
- 사용자 위치 기반 최적 서버 선택

#### CDN (Content Delivery Network)
- 전 세계 분산된 엣지 서버에서 컨텐츠 제공
- **CDN vs S3**: CDN은 전송 최적화, S3는 데이터 저장
- **동기화**: Push/Pull/Hybrid 방식

---

### 클라우드 서비스 모델

| 구분 | IaaS (Infra as a Service)                                      | PaaS (Platform as a Service)                           | SaaS (Software as a Service)                           |
| ---- | -------------------------------------------------------------- | ------------------------------------------------------ | ------------------------------------------------------ |
| 정의 | 클라우드가 인프라만 제공                                       | 클라우드가 인프라와 필요한 서비스를 제공               | 완전한 서비스를 클라우드에서 제공받아 사용             |
| 예시 | AWS EC2                                                        | Heroku, Google App Engine                              | Google Docs, Salesforce                                |
| 이점 | - 사용자가 OS와 애플리케이션을 직접 설치<br>- 유연한 환경 제공 | - 개발자가 애플리케이션 개발에만 집중<br>- 관리가 용이 | - 소프트웨어 설치 및 유지보수 필요 없음<br>- 쉬운 접근 |

---

# 스프링

---

## 스프링 프레임워크

| 개념 | 설명 |
|------|------|
| 스프링 프레임워크 | 자바의 오픈 소스 프레임워크 중 하나로, DI와 IoC를 통해 결합도를 낮추며, 스프링 컨테이너가 자바 객체를 관리 |
| IOC (제어의 역전) | 스프링 컨테이너가 개발자 대신 스프링 빈들을 관리. 객체의 제어권이 개발자에서 컨테이너로 역전됨. 의존성 주입의 상위 개념 |
| DI (의존성 주입) | 어떤 객체에 스프링 컨테이너가 다른 객체와 의존성을 맺어주는 행위. 클래스 간의 의존 관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결. 결합도를 낮추고 모듈 간 독립성을 높임 |
| 스프링 컨테이너 | 애플리케이션 실행 시 생성되며, 빈의 생명 주기와 의존 관계를 관리. 자바 객체를 관리하며 자동으로 객체 생성 및 의존 관계 주입 처리 |

---

## 의존성 주입의 종류

| 구분 | 생성자 주입 | 필드 주입 |
|------|------------|----------|
| 정의 | 의존성이 필요한 객체를 생성할 때 생성자를 통해 주입 | 스프링 컨테이너가 클래스의 필드에 직접 의존성을 주입 |
| 사용 방법 | `@Autowired` 어노테이션을 생성자에 사용하지 않아도 스프링 4.3 이후 부터는 자동으로 의존성을 주입 | 클래스의 필드에 `@Autowired` 어노테이션을 붙여 사용 |
| 장점 | 의존성 불변성 보장(final), 의존성 명시성 및 가시성 증가, 순환 참조 방지, 테스트 용이 | 코드가 간결해짐, 쉽게 의존성을 주입할 수 있음 |
| 단점 | 초기 설정 코드가 늘어날 수 있음 | 테스트 어려움, 불변성 보장 불가, 순환 참조 가능성 |

---

## 스프링 빈 (Spring Bean)

| 개념 | 설명 |
|------|------|
| Bean | 스프링 컨테이너가 관리하는 자바 객체. `@Component`, `@Bean` 어노테이션이나 XML 설정을 통해 등록 가능 |
| Bean scope | 싱글톤(스프링 컨테이너의 시작과 종료까지 한 개의 객체만을 가짐), 프로토 타입(빈 요청 시 매번 새 객체 생성), 요청 스코프(HTTP 요청당 한 번 생성), 세션 스코프(HTTP 세션당 한 번 생성) |
| 생명 주기 | 스프링 컨테이너에 의해 관리됨. 빈 생성 -> 의존 관계 주입 -> 초기화 콜백(`@PostConstruct`) -> 소멸 전 콜백(`@PreDestroy`) -> 소멸 |

---

## 스프링 빈 등록 방법: @Bean vs @Component

| 구분 | @Bean | @Component |
|------|-------|------------|
| 정의 | `@Configuration`이 붙은 설정 클래스 내의 메소드에 `@Bean` 어노테이션을 설정하여 해당 메소드가 반환하는 객체를 스프링 빈으로 등록 | 클래스 레벨에 설정하여 스프링이 해당 클래스의 인스턴스를 자동으로 스프링 빈으로 등록 |
| 예시 | 설정 클래스(Java Config) 내에서 메소드를 통해 빈을 직접 정의하고 등록 | 클래스에 `@Component`를 직접 붙이거나, 이를 포함하는 `@Service, @Repository, @Controller` 등 사용 |
| 사용 상황 | 빈의 생성과 관리를 개발자가 직접 제어해야 할 때, 특히 외부 라이브러리 등 직접 작성하지 않은 클래스를 빈으로 등록할 때 사용 | 스프링이 클래스 패스를 스캔하여 빈을 자동으로 등록해야 할 때, 주로 개발자가 작성한 클래스에 사용 |

---

## 스프링 프레임워크 vs 스프링 부트

| 구분 | 스프링 프레임워크 | 스프링 부트 |
|------|------------------|------------|
| 목적 | 강력한 DI 및 IoC 지원을 통한 애플리케이션 개발 | 스프링의 복잡한 구성을 단순화, 빠른 개발 및 배포 중점 |
| 특징 | 다양한 환경 설정 필요 | 설정 자동화, 내장 서버 제공, 빠른 프로토타이핑 가능 |

---

## 라이브러리 vs 프레임워크

| 구분 | 라이브러리 | 프레임워크 |
|------|-----------|-----------|
| 제어권 | 사용자가 흐름 제어 | 프레임워크가 전체적인 흐름 제어 (IoC 적용) |
| 사용 시점 | 필요할 때 가져다 사용 | 전체적인 흐름 및 규칙에 맞추어 사용 |

---

## AOP (Aspect-Oriented Programming)

| 개념 | 설명 | 주요 사용 사례 |
|------|------|---------------|
| AOP | 프로그래밍에서 반복되는 관심사(로깅, 보안, 트랜잭션 등)를 모듈화하여 관리하는 방법. 코드 중복을 줄이고 재활용성과 유지보수를 용이하게 함 | 로깅, 보안, 트랜잭션 관리 |
| Proxy | 다른 객체에 대한 접근을 제어하거나 추가 기능을 제공하는 객체. 스프링에서 AOP를 위해 proxy를 사용하며, 클라이언트가 실제 객체 대신 프록시를 통해 상호작용하게 함 | 로깅, 접근 제어, 리소스 관리 |
| @Transactional | Spring Framework에서 제공하는 어노테이션으로, 선언적 트랜잭션 관리를 가능하게 함. 메서드나 클래스에 적용되며, 해당 범위의 작업을 하나의 트랜잭션으로 묶어 관리 | 데이터베이스 트랜잭션의 시작, 커밋, 롤백 |
| 관련 용어 | Aspect: 공통된 관심사의 모듈화된 버전, Pointcut: Aspect가 적용될 위치(trigger), Advice: joinpoint에서 무엇을 실행될지 정의 (Before, Around 등) | |

---

## 스프링 보안 (Spring Security)

| 개념 | 설명 |
|------|------|
| 인증 (Authentication) | 사용자가 누구인지 확인하는 과정 |
| 인가 (Authorization) | 인증된 사용자가 특정 리소스에 접근할 권한이 있는지 확인 |
| JWT | JSON Web Token, 상태가 없는 인증 토큰 |
| OAuth 2.0 | 외부 서비스 인증을 위한 개방형 표준 |
| Filter Chain | 요청을 처리하기 전에 거치는 보안 필터들의 연쇄 |

---

## 스프링 캐시 (Spring Cache)

| 어노테이션 | 설명 |
|------------|------|
| @Cacheable | 메서드 결과를 캐시에 저장 |
| @CacheEvict | 캐시에서 데이터 제거 |
| @CachePut | 캐시 데이터 갱신 |
| @Caching | 여러 캐시 작업을 조합 |

---

## 스프링 프로파일 (Spring Profiles)

| 개념 | 설명 |
|------|------|
| 정의 | 환경별로 다른 설정을 적용할 수 있는 기능 |
| 사용법 | `@Profile("dev")`, `application-dev.yml` |
| 활성화 | `spring.profiles.active=dev` |
| 용도 | 개발/테스트/운영 환경 분리 |

---

## Spring에서 CORS 에러 해결 방법

| 해결 방법 | 설명 |
|----------|------|
| @CrossOrigin | 컨트롤러 클래스에 사용하여 특정 오리진, HTTP 메서드, 헤더 등에 대한 CORS 요청 허용 |
| 전역 CORS 설정 | `WebMvcConfigurer` 구현으로 애플리케이션 전체에 CORS 정책 적용 |
| 필터 구현 | 직접 CORS 설정을 위한 필터 구현 |

---

## MSA (마이크로 서비스 아키텍처)

| 특징 | 설명 |
|------|------|
| 정의 | 소프트웨어를 작고 독립적으로 배포 가능한 서비스의 집합으로 구성하는 아키텍처로 각 서비스는 특정 비지니스 기능을 담당. 서비스 간에는 네트워크를 통해 통신 |
| 장점 | 분산 개발: 팀 간의 독립적인 개발과 협업을 촉진, 독립적 배포: 각 서비스가 독립적으로 배포되어 서비스 업데이트와 확장이 용이, 기능 중심 구성, 기술 다양성, 장애 격리 |
| 단점 | 서비스 간 통신 복잡성 증가, 데이터 관리의 복잡성, 전체 시스템의 통합 테스트 어려움 |

---

## API 게이트웨이

| 기능 | 설명 |
|------|------|
| 정의 | 마이크로 서비스 아키텍처에서 클라이언트의 요청을 받아 적절한 마이크로 서비스로 라우팅하고, 다양한 부가 기능을 제공하는 관리 포인트 |
| 기능 | 라우팅: 요청을 적절한 서비스로 전달, 인증 및 권한 부여: 접근 제어와 보안 강화, 로깅: 요청과 응답에 대한 로깅, 캐싱: 자주 요청되는 데이터 캐싱, 요청/응답 변환 |
| 장점 | 서비스 통합 관리 용이, 보안, 로깅 등의 부가 기능 제공으로 개발 및 운영 효율성 향상 |
| 단점 | API 게이트웨이 자체의 성능 및 가용성 관리 필요 |

---

## 스프링 배치 (Spring Batch)

### Tasklet vs Chunk 비교

| 구분 | Tasklet | Chunk (ItemReader/Writer) |
|------|---------|---------------------------|
| 용도 | 단순 작업 (파일 삭제, 프로시저 호출) | 대용량 데이터 처리 (100만 건) |
| 트랜잭션 | 전체가 하나의 트랜잭션 | Chunk Size마다 커밋 |
| 메모리 | 모든 데이터 메모리 적재 (OOM 위험) | Chunk Size만큼만 적재 |
| 재시작 | 처음부터 | 실패 지점부터 |
| 적합한 경우 | 10건 이하 간단한 작업 | 1만 건 이상 대용량 |

### Chunk 방식 (권장)

**동작 방식**:
```
[100만 건 데이터]
    ↓
1. Reader: 1000건 읽기
2. Processor: 1000건 가공
3. Writer: 1000건 쓰기
4. Commit
    ↓
(반복 1000번)
```

**장점**:
1. 메모리 안전: 1000건만 메모리에 적재
2. 짧은 트랜잭션: 1000건 처리하고 바로 커밋
3. 재시작 가능: 50만 건에서 실패 → 그 지점부터 재개
4. 병렬 처리: 멀티스레드 설정 가능

**Chunk Size 설정**
- 기본값: 1000
- 작으면 (100): 메모리 적게 사용, Commit 횟수 많아서 느림
- 크면 (10000): Commit 횟수 적어서 빠름, 메모리 많이 사용
- 권장: 1000 (성능 테스트로 조정)

### 면접 질문

**Q1. 100만 건 데이터 Tasklet vs Chunk 중 어느 걸 선택?**
→ Chunk 방식 - Tasklet은 OOM 발생, Chunk는 1000건씩 안전하게 처리

**Q2. Chunk Size는 어떻게 정하나요?**
→ 기본값 1000으로 시작, 부하 테스트로 조정

**Q3. 배치 실행 중 50만 건에서 실패하면?**
→ Chunk: 마지막 Commit 지점부터 재시작
→ Tasklet: 처음부터 다시 시작

---

## Connection Pool

### 핵심 개념

Connection Pool: DB 커넥션을 미리 생성해서 재사용하는 기법

**왜 필요한가?**
- DB 커넥션 생성 비용이 높음 (TCP Handshake + 인증 = 100ms)
- Pool 사용 시 즉시 획득 (1ms 미만)
- 성능 100배 향상

---

### HikariCP 핵심 설정값

**Pool Size 설정**

| 설정값 | 설명 | 기본값 | 권장값 |
|--------|------|--------|--------|
| maximumPoolSize | 최대 커넥션 수 | 10 | CPU 코어 수 x 2 ~ 4 |
| minimumIdle | 유휴 커넥션 최소 개수 | = maximumPoolSize | maximumPoolSize와 동일 (고정 풀) |

**maximumPoolSize 설정 공식**:
```
connections = ((CPU 코어 수 x 2) + 디스크 수)

예시:
- CPU 8코어, SSD 1개: (8 x 2) + 1 = 17개
- 실무 시작: 10 ~ 20개로 시작 → 부하 테스트 → 튜닝
```

**minimumIdle 권장 설정**:
```yaml
# 권장: 고정 풀 (안정적)
spring.datasource.hikari.minimum-idle: 10
spring.datasource.hikari.maximum-pool-size: 10

# 비권장: 동적 풀 (커넥션 생성/삭제 오버헤드)
spring.datasource.hikari.minimum-idle: 5
spring.datasource.hikari.maximum-pool-size: 10
```

---

**Timeout 설정**

| 설정값 | 설명 | 기본값 | 권장값 |
|--------|------|--------|--------|
| connectionTimeout | 커넥션 획득 대기 시간 | 30초 | 5초 ~ 10초 |
| idleTimeout | 유휴 커넥션 유지 시간 | 10분 | 10분 |
| maxLifetime | 커넥션 최대 수명 | 30분 | 28분 (DB timeout보다 짧게) |
| keepaliveTime | 커넥션 살아있는지 확인 주기 | 0 (비활성) | 5분 |

**connectionTimeout** (커넥션 획득 대기):
```
요청 → Pool에서 커넥션 요청
  ↓ Pool이 가득 참
  ↓ connectionTimeout(5초) 대기
  ↓ 시간 초과 → SQLTransientConnectionException
```

**maxLifetime** (커넥션 수명):
```
문제: DB는 30분 후 커넥션 강제 종료
해결: HikariCP가 28분에 미리 재생성

maximumLifetime: 1680000 (28분)  # DB의 30분보다 짧게
```

---

### 실무 설정 예시

```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20              # CPU 8코어 x 2 + 여유
      minimum-idle: 20                   # 고정 풀
      connection-timeout: 5000           # 5초
      max-lifetime: 1680000              # 28분 (DB 30분보다 짧게)
      idle-timeout: 600000               # 10분
      keepalive-time: 300000             # 5분
      leak-detection-threshold: 0        # 운영 환경: 비활성화
      connection-test-query: SELECT 1
```

---

### Connection Pool Size 튜닝

**튜닝 절차**:
```
1. 초기 설정: CPU 코어 수 x 2 (예: 8코어 → 16개)
2. 부하 테스트: JMeter로 동시 요청 1000개
3. 모니터링:
   - active (사용 중): 16/16 (100%) → 부족
   - waiting (대기): 50개 → Pool 증가 필요
4. 증가: 20개로 증가
5. DB 모니터링:
   - DB CPU: 80% → 여유 있음 → OK
   - DB CPU: 95% → DB 한계 → Pool 줄이기
6. 재테스트 → 최적값 찾기
```

**모니터링 지표** (Actuator + Prometheus):
```
hikaricp_connections_active: 사용 중 커넥션
hikaricp_connections_idle: 유휴 커넥션
hikaricp_connections_pending: 대기 중인 요청
hikaricp_connections_timeout: 타임아웃 발생 수
```

---

### 면접 질문

**Q1. Connection Pool Size는 어떻게 설정하나요?**

```
초기값은 CPU 코어 수 x 2로 설정합니다. (예: 8코어 → 16개)

부하 테스트를 통해 모니터링하면서 튜닝합니다:
- active가 100%이고 waiting이 많으면 → Pool 증가
- DB CPU가 95% 이상이면 → Pool 감소 (DB가 병목)

실무에서는 Prometheus로 모니터링하면서 점진적으로 조정합니다.
```

---

**Q2. maximumPoolSize를 크게 하면 안 되나요?**

```
안 됩니다. 세 가지 문제가 있습니다:

1. DB 부하 증가: DB가 동시에 처리 가능한 커넥션은 제한적
2. 메모리 낭비: 커넥션 1개당 1~2MB 소비
3. Context Switching: 커넥션이 많으면 DB 성능 저하

공식: connections = (CPU 코어 수 x 2) + 디스크 수
→ 8코어 기준 10~20개가 적정
→ 무조건 크게 하는 것보다 DB 확장(Read Replica)이 더 효과적
```

---

**Q3. maxLifetime은 왜 DB timeout보다 짧게 설정하나요?**

```
DB가 먼저 커넥션을 끊으면 에러가 발생하기 때문입니다.

예시:
- MySQL wait_timeout: 28800초 (8시간)
- HikariCP maxLifetime: 1680000ms (28분) ← 훨씬 짧게

이유:
- DB가 8시간 후 강제 종료하기 전에
- HikariCP가 28분마다 미리 재생성
- "Connection reset by peer" 에러 방지

권장: DB timeout - 2분
```

---

**Q4. Connection Pool Exhausted가 발생하면?**

```
증상:
SQLTransientConnectionException: Connection is not available,
request timed out after 5000ms

원인 3가지:
1. 롱 트랜잭션 (5시간 배치 등) → 커넥션 독점
2. 커넥션 누수 (close 안 함) → 계속 증가
3. Pool Size 부족 → 트래픽 급증

해결 단계:
1. 즉시: 모니터링으로 원인 파악
   - 롱 트랜잭션: APM에서 5분 이상 트랜잭션 확인
   - 커넥션 누수: leak-detection-threshold 활성화
   - 트래픽 급증: 요청 수 확인

2. 긴급 대응:
   - Pool Size 일시적 증가 (30 → 50)
   - 서버 스케일 아웃

3. 근본 해결:
   - 롱 트랜잭션 쪼개기 (Chunk 단위)
   - 불필요한 @Transactional 제거
   - 인덱스 최적화
   - Read Replica 도입 (읽기 분산)
```

---

**Q5. 롱 트랜잭션이 있으면 어떤 문제가 발생하나요?**

```
5가지 문제가 발생합니다:

1. 락 누적 (가장 심각)
   - 오래 동안 특정 데이터에 락 유지
   - 다른 트랜잭션들 대기 → 서비스 마비

2. 커넥션 풀 고갈
   - 커넥션 오래 점유 → 남은 커넥션 부족
   - 다른 요청이 커넥션 못 받음
   - "Connection pool exhausted" 에러

3. 메모리/디스크 증가 (MVCC 오버헤드)
   - Undo Log: 이전 버전 데이터 계속 보관
   - Table Bloating: 테이블 크기 증가 → 성능 저하

4. 복제 지연 (Replication Lag)
   - Master-Slave 구조에서 Slave가 Master 따라잡기 어려움

5. 장애 복구 시간 증가
   - 쌓인 Redo Log가 많아서 복구 느림

해결 방법:
1. 트랜잭션 쪼개기 (Chunk 단위)
2. 인덱스 최적화 (WHERE 절에 인덱스 사용)
```

---

## Thread Pool

### 핵심 개념

Thread Pool: 요청을 처리할 스레드를 미리 생성해서 재사용

**왜 필요한가?**
- 스레드 생성 비용 절약 (1ms → 재사용 시 0.001ms)
- 동시 요청 수 제한 → 서버 보호
- 메모리 사용량 예측 가능

---

### Tomcat 핵심 설정값

| 설정값 | 설명 | 기본값 | 권장값 |
|--------|------|--------|--------|
| maxThreads | 최대 스레드 수 | 200 | 200 ~ 400 |
| minSpareThreads | 최소 유휴 스레드 | 10 | 25 |
| acceptCount | 대기 큐 크기 | 100 | 100 ~ 200 |
| connectionTimeout | 요청 타임아웃 | 20초 | 30초 |

**maxThreads** (최대 스레드):
```
동시 처리 가능한 요청 수
200개 요청 동시 처리 → 201번째는 대기

너무 크면: Context Switching 증가, CPU 낭비
너무 작으면: 요청 대기 시간 증가
```

**acceptCount** (대기 큐):
```
maxThreads 초과 시 대기 큐에 쌓임
200개 스레드 + 100개 큐 = 최대 300개 요청

큐 초과 → Connection Refused (503)
```

---

### Spring Boot 설정

```yaml
server:
  tomcat:
    threads:
      max: 200              # 최대 스레드
      min-spare: 25         # 최소 유휴 스레드
    accept-count: 100       # 대기 큐
    connection-timeout: 30s # 타임아웃
    max-connections: 8192   # 최대 커넥션 (keep-alive)
```

---

### Virtual Thread (Java 21)

**Platform Thread vs Virtual Thread**:

| 구분 | Platform Thread | Virtual Thread |
|------|----------------|----------------|
| 생성 비용 | 높음 (OS 스레드) | 낮음 (JVM 스레드) |
| 메모리 | 1MB/스레드 | 10KB/스레드 |
| 개수 | 수백~수천 개 | 수백만 개 |
| 블로킹 | OS 스레드 블로킹 | JVM이 다른 작업 실행 |
| 사용 | 기존 방식 | Java 21+ |

**Virtual Thread 활성화**:
```yaml
spring:
  threads:
    virtual:
      enabled: true  # Spring Boot 3.2+
```

**장점**:
```
I/O 블로킹 시:
- Platform Thread: OS 스레드 대기 (낭비)
- Virtual Thread: JVM이 다른 Virtual Thread 실행 (효율적)

→ 동시 처리량 10배 증가 (I/O 많은 경우)
```

**언제 사용?**
```
I/O 집약적: API 호출, DB 조회 많음 → 도입
CPU 집약적: 영상 처리, 암호화 → 효과 없음
synchronized 많이 사용: Pinning 문제 → 비추천
```

---

### 면접 질문

**Q1. maxThreads는 어떻게 설정하나요?**

```
기본값 200으로 시작해서 부하 테스트로 튜닝합니다.

고려사항:
1. CPU 코어 수: I/O 많으면 코어 수 x 50 (8코어 → 400)
2. 메모리: 스레드 1개당 1MB (200개 → 200MB)
3. 응답 시간: 스레드 부족 시 대기 시간 증가

모니터링하면서:
- 스레드 사용률 > 80% → 증가
- CPU > 90% → 감소 (CPU가 병목)
```

---

**Q2. Virtual Thread는 언제 도입하나요?**

```
I/O 집약적이고 동시 요청이 많을 때 도입합니다.

도입 효과가 큰 경우:
- 외부 API 호출 많음 (50% 이상)
- DB 조회가 대부분
- 동시 요청 10,000+ TPS

도입 효과 없는 경우:
- CPU 집약적 작업 (영상 처리, 계산)
- synchronized 많이 사용
- ThreadLocal 의존성 높음

실무: Spring Boot 3.2+ 환경에서 설정 1줄로 적용 가능
```

---

## 스레드 풀 vs 커넥션 풀

### 핵심 비교

| 구분 | 스레드 풀 | 커넥션 풀 |
|------|---------|----------|
| 뭘 재사용? | 스레드 (요청 처리) | DB 커넥션 |
| 왜 필요? | 스레드 생성 비용 ↓ | DB 연결 비용 ↓ |
| 예시 | Tomcat 스레드 200개 | HikariCP 커넥션 10개 |
| 문제 | 느린 요청이 스레드 점유 → 대기 | 롱 트랜잭션이 커넥션 점유 → 고갈 |
| 설정 | maxThreads: 200 | maximumPoolSize: 10 |

---

### 동작 흐름

```
[클라이언트 요청]
       ↓
[1] Tomcat 스레드 풀 → 스레드 1 할당
       ↓
[2] @Transactional 시작
       ↓
[3] HikariCP 커넥션 풀 → 커넥션 A 획득
       ↓
[4] ThreadLocal에 저장: 스레드 1 → 커넥션 A
       ↓
[5] DB 쿼리 실행
       ↓
[6] @Transactional 종료 → 커넥션 A 반납
       ↓
[7] 응답 완료 → 스레드 1 반납
```

---

### 최적 비율

스레드 풀 > 커넥션 풀 (일반적):
```
스레드: 200개
커넥션: 10~20개

이유:
- 하나의 요청이 항상 DB를 쓰는 건 아님 (캐싱, 계산)
- DB는 병목이 되기 쉬움 (디스크 I/O)
- 스레드는 CPU만 있으면 됨

비율: 스레드 10:1 커넥션
```

---

### 면접 질문

**Q. 스레드 풀과 커넥션 풀 비율은?**

```
일반적으로 10:1 비율입니다.

예시:
- 스레드: 200개
- 커넥션: 20개

이유:
- 모든 요청이 DB를 쓰는 건 아님 (캐싱, 계산 등)
- DB가 병목이기 때문에 커넥션을 많이 늘려도 효과 없음
- 오히려 DB 부하만 증가

DB 부하가 높으면:
- 커넥션 증가보다는 Read Replica로 읽기 분산
- 쿼리 최적화, 인덱스 추가가 우선
```

---

## 스프링 관련 주요 개념 정리

| 주제 | 설명 |
|------|------|
| 스프링 클라우드 | MSA(Microservices Architecture)를 구축하기 위한 스프링 기반의 도구 모음. 서비스 디스커버리, 설정 관리, 회로 차단기 패턴, 인텔리전트 라우팅 등의 패턴을 손쉽게 구현할 수 있도록 지원 |
| 스프링 시큐리티 | 스프링 기반 애플리케이션의 보안을 위한 프레임워크. 사용자 인증(Authentication)과 권한 부여(Authorization), CSRF 보호, 세션 고정 보호, 공격 방어 기능 포함 |
| 스프링 WebFlux | 스프링 5에서 도입된 비동기적, 논블로킹 I/O를 지원하는 웹 프레임워크. Reactor를 사용하여 이벤트 루프 기반의 비동기 모델을 제공 |
| 스프링 배치 | 대량의 데이터 작업을 효율적으로 수행할 수 있도록 설계된 경량, 포괄적인 배치 프레임워크 |

---

## 핵심 체크리스트

- IoC/DI: 제어의 역전, 의존성 주입 개념
- 의존성 주입: 생성자 주입 vs 필드 주입 차이
- 빈 생명주기: 생성 → 주입 → 초기화 → 소멸
- @Bean vs @Component: 등록 방식 차이
- AOP: Aspect, Pointcut, Advice 개념
- Spring Batch: Tasklet vs Chunk, Chunk Size 설정
- Connection Pool: HikariCP 설정, maximumPoolSize 공식
- Thread Pool: maxThreads 설정, Virtual Thread
- 풀 비율: 스레드 10:1 커넥션

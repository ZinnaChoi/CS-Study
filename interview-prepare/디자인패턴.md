# 디자인 패턴

- 소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 할 수 있는 해결책
- 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것

### 디자인 패턴의 종류

| 디자인 패턴 종류 | 설명                                                                                                                            | 예시                                          |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------- |
| 생성 패턴        | 객체 생성 방법이 들어간 디자인 패턴. 클래스로부터 객체 생성 방법                                                                | 싱글톤, 팩토리, 추상 팩토리, 빌더, 프로토타입 |
| 구조 패턴        | 객체나 클래스 등으로 큰 구조를 만들 때 유연하고 효과적으로 만드는 벙법                                                          | 프록시, 어뎁터, 브릿지, 복합체, 데코레이터    |
| 행동 패턴        | 객체나 클래스 간의 알고리즘, 책임 할당에 관한 디자인 패턴. 한 객체가 수행할 수 없는 작업을 여러개의 객체로 어떻게 분배할 것인가 | 이터레이터, 옵저버, 전략, 책임연쇄, 커멘드    |
| 기타             |                                                                                                                                 | Flux 패턴, MVC 패턴, MVVM 패턴                |

### 싱글톤 패턴

- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
- 객체 생성 비용이 적게 들어 I/O 연결 작업에 자주 사용되지만, 의존성이 높아져 TDD를 할 때 걸림돌
- enum 또는 중첩 클래스 (Lazy Holder)를 사용하여 java에서 싱글톤 패턴을 구현

### 팩토리 패턴

- 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 대한 구체적인 내용을 결정하는 패턴
- 상위 클래스는 객체 생성 방식에 대해 알 필요가 없고 객체 생성 로직은 하위 클래스에서만 관리되어 유지보수성이 증가

### 프록시 패턴

- 실제 객체에 대한 대리자 객체를 제공
- 객체가 어떤 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채서 해당 접근을 필터링하거나 수정
- ex) 프록시 서버 : 캐싱, 로깅

### 이터레이터 패턴

- 이터레이터를 사용하여 컨테이너의 요소들에 접근하는 디자인 패턴
- 각기 다른 자료구조들을 똑같은 인터페이스로 순회 가능

### 전략 패턴

- 전략이라고 부르는 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 디자인 패턴
- 코드의 유연성과 확장성이 향상

### 옵저버 패턴

- 주체가 어떤 객체의 상태 변화를 관찰하다가, 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 객체의 변화를 알려주는 디자인 패턴

### MVC 패턴

- Model, View, Controller 로 이루어진 디자인 패턴

  - Model : 데이터베이스, 상수, 변수
  - View : UI
  - Controller: 모델과 뷰를 잇는 다리 역할. 이벤트의 메인 로직을 담당

- 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중
- 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡
- 컨트롤러와 뷰는 1: N
- 뷰는 컨트롤러를 참조하지 않음

#### 디스패터 서블릿의 요청 처리

- 클라이언트가 요청 시 어떤 컨트롤러에게 처리하게 할지 결정하게 하는 역할
- `@RequestMapping`

#### MVP 패턴

- 컨트롤러가 Presenter(프레젠터)로 교체된 패턴. 뷰와 프리젠터는 1:1 관게이므로 MVC보다 더 강한 결합을 가짐
- 뷰는 프리젠터를 참조

#### MVVM 패턴

- 컨트롤러가 VM(뷰 모델)로 바뀐 패턴. VM은 뷰를 추상화한 계층이며 VM: V = 1: N 이라는 관계를 가짐
- 뷰는 뷰 모델을 참조
- 대표: Vue.js

### Flux 패턴

- 단방향으로 데이터 흐름을 관리하는 디자인 패턴
- 데이터의 일관성 증대, 버그 찾기 쉬움
- action(사용자 이벤트), dispatcher(행위), store(도메인, 애플리케이션의 상태 저장), view(UI)로 구성

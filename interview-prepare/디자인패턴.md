# 디자인 패턴

- 소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 할 수 있는 해결책
- 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것

### 디자인 패턴의 종류

| 디자인 패턴 종류 | 설명                                                                                                                            | 예시                                          |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------- |
| 생성 패턴        | 객체 생성 방법이 들어간 디자인 패턴. 클래스로부터 객체 생성 방법                                                                | 싱글톤, 팩토리, 추상 팩토리, 빌더, 프로토타입 |
| 구조 패턴        | 객체나 클래스 등으로 큰 구조를 만들 때 유연하고 효과적으로 만드는 벙법                                                          | 프록시, 어뎁터, 브릿지, 복합체, 데코레이터    |
| 행동 패턴        | 객체나 클래스 간의 알고리즘, 책임 할당에 관한 디자인 패턴. 한 객체가 수행할 수 없는 작업을 여러개의 객체로 어떻게 분배할 것인가 | 이터레이터, 옵저버, 전략, 책임연쇄, 커멘드    |
| 기타             |                                                                                                                                 | Flux 패턴, MVC 패턴, MVVM 패턴                |

### 싱글톤 패턴

- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
- 객체 생성 비용이 적게 들어 I/O 연결 작업에 자주 사용되지만, 의존성이 높아져 TDD를 할 때 걸림돌
- enum 또는 중첩 클래스 (Lazy Holder)를 사용하여 java에서 싱글톤 패턴을 구현

### 팩토리 패턴

- 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 대한 구체적인 내용을 결정하는 패턴
- 상위 클래스는 객체 생성 방식에 대해 알 필요가 없고 객체 생성 로직은 하위 클래스에서만 관리되어 유지보수성이 증가

### 프록시 패턴

- 실제 객체에 대한 대리자 객체를 제공
- 객체가 어떤 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채서 해당 접근을 필터링하거나 수정
- ex) 프록시 서버 : 캐싱, 로깅

### 이터레이터 패턴

- 이터레이터를 사용하여 컨테이너의 요소들에 접근하는 디자인 패턴
- 각기 다른 자료구조들을 똑같은 인터페이스로 순회 가능

### 전략 패턴

- 전략이라고 부르는 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 디자인 패턴
- 코드의 유연성과 확장성이 향상

### 옵저버 패턴

- 주체가 어떤 객체의 상태 변화를 관찰하다가, 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 객체의 변화를 알려주는 디자인 패턴

### MVC 패턴

| 구성 요소      | 설명                                                                                                                              |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| **Model**      | - 데이터 관리와 비즈니스 로직을 처리.<br>- Spring에서는 서비스와 레포지토리 계층이 이에 해당.                                     |
| **View**       | - 사용자 인터페이스를 담당.<br>- HTML, JSP 등 웹 페이지 표현에 사용.                                                              |
| **Controller** | - 사용자의 요청을 처리하고, Model과 View를 중개.<br>- Spring MVC에서는 `@Controller` 어노테이션을 사용한 클래스가 이 역할을 수행. |

#### **MVC 패턴의 핵심**

- 애플리케이션의 구성 요소를 Model, View, Controller로 구분하여, 각각의 역할에 집중할 수 있도록 도와줌.
- 사용자의 요청과 비즈니스 로직의 처리, 그리고 사용자에게 결과를 보여주는 부분이 명확히 분리되어, 애플리케이션의 유지보수성과 확장성을 높임

#### **Spring MVC의 특징**

- Spring Framework의 일부로, MVC 패턴을 기반으로 하는 웹 애플리케이션을 쉽게 개발할 수 있도록 지원.
- DispatcherServlet이 중앙 처리기 역할을 하여, 사용자의 요청을 알맞은 Controller에 전달하고, 처리 결과(Model 생성)를 View로 반환
- 각 계층 간의 결합도를 낮추어 애플리케이션의 개발과 테스트가 용이

#### MVP 패턴

- 컨트롤러가 Presenter(프레젠터)로 교체된 패턴. 뷰와 프리젠터는 1:1 관게이므로 MVC보다 더 강한 결합을 가짐
- 뷰는 프리젠터를 참조

#### MVVM 패턴

- 컨트롤러가 VM(뷰 모델)로 바뀐 패턴. VM은 뷰를 추상화한 계층이며 VM: V = 1: N 이라는 관계를 가짐
- 뷰는 뷰 모델을 참조
- 대표: Vue.js

### Flux 패턴

- 단방향으로 데이터 흐름을 관리하는 디자인 패턴
- 데이터의 일관성 증대, 버그 찾기 쉬움
- action(사용자 이벤트), dispatcher(행위), store(도메인, 애플리케이션의 상태 저장), view(UI)로 구성

### MSA (마이크로 서비스 아키텍처)

- 하나의 큰 어플리케이션을 작은 서비스 단위로 나누고 개발하고 관리하는 방식.
- 각각의 서비스는 독립적으로 개발, 배포, 운영될 수 있으며, 특정 기능을 중심으로 서비스가 구성됨
- 장애가 발생했을 때 영향을 최소화할 수 있고 서비스의 확장성과 유지보수성이 높지만 시스템 전체의 복잡도가 증가하는 단점도 존재
- 각각의 서비스들은 서로 다른 언어와 프레임워크로 구성될 수 있고, 서비스의 확장이 용이
- 복잡한 서비스 간 통신, 데이터 관리의 어려움

### API 게이트웨이란?

- MSA 에서 클라이언트와 서비스 간의 중간 단계로 모든 API 호출을 중앙에서 처리
- 라우팅, 인증, 로깅, 캐싱과 같은 기능 제공

### AOP

> Aspect-Oriented Programming (관점 지향 프로그래밍)

- 개발에서 반복되는 관심사 (로깅, 보안, 트랜젝션)를 모듈화하는 프로그래밍 접근 방법
- 트랜젝션이나 로깅, 보안 등과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있음
- 중복 코드 제거, 재활용성의 극대화, 변화 수용의 용이성이 좋음
- 스프링은 AOP를 위해 proxy 패턴을 채택하여 사용
- @Aspect 어노테이션을 사용하여 로깅, 트랜젝션 관리 등을 모듈화 가능

### Proxy

- 다른 객체를 감싸서 그 객체에 대한 접근을 제어하거나 추가 기능을 제공하는 중간 역할을 하는 객체
- 주로 AOP에서 사용되며 클라이언트가 직접 실제 객체에 접근하는 대신 프록시를 통해 상호작용
- 이를 통해 로깅, 보안, 트랜젝션 관리와 같은 부가적인 작업 수행 가능

### @Transactional

- Spring AOP의 대표적인 예시로 프록시 방식으로 동작한다
- 메소드나 클래스에 `@Transactional` 어노테이션을 추가하면, 해당 메서드 또는 클래스에서 실행되는 작업들이 하나의 트렌젝션으로 묶이게 된다
- 이 어노테이션을 사용하여 트랜잭션을 관리할 수 있으며, 트랜잭션의 시작, 커밋, 롤백 등을 자동으로 처리할 수 있다

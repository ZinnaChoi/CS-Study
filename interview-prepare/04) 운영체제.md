### 프로세스 VS 스레드

| 개념     | 설명                                                                                                                                                                                                                                                  |
| -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 프로세스 | - 실행 중인 프로그램의 인스턴스. <br>- 독립적인 메모리 공간(코드, 데이터, 힙, 스택)을 가짐 <br>- 운영체제로부터 자원을 할당 받음 <br>- 각 프로세스는 서로 독립적이기 때문에 하나의 프로세스가 다른 프로세스의 자원에 직접 접근하는 것은 허용되지 않음 |
| 스레드   | - 프로세스 내에서 실행되는 실행의 흐름. <br>- 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 프로세스의 자원(메모리)을 공유 <br>- 컨텍스트 스위칭이 더 빠르고 효율적                                                                            |

---

### 컨텍스트 스위칭

- 프로세스 또는 스레드의 상태를 저장하고 복원하는 과정. 프로세스의 중단, 재시작
- 한 Task 가 끝날 때까지 기다리는 것이 아니라 여러 작업을 번갈아가며 실행해서 동시에 처리할 수 있도록 하는 방법

---

### 동기/ 비동기/ 블로킹/ 논블로킹

| 개념          | 설명                                                                                                                                                                                                                                                                                                                                                                           |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 동기          | - 현재 실행 중인 작업이 **완료될 때까지 다음 작업이 기다려야** 하는 방식. <br>- **작업의 처리 순서**가 보장되며, 여러 스레드가 동시에 공유 지원에 접근하는 것을 막기 때문에 Thread safety 하다<br>- 어떤 작업이 많은 시간을 소요할 경우, 전체 시스템의 효율성이 저하                                                                                                           |
| 비동기(Async) | - 현재 실행 중인 작업의 **완료를 기다리지 않고, 다음 작업을 바로 시작**. <br>- 동시에 여러 작업을 처리할 수 있게 하여 전체적인 시스템의 처리량을 향상시키지만, 작업의 완료 순서를 보장하기 어렵고, 동시성 관리가 필요 <br>- CPU나 메모리를 많이 사용하는 경우 과부하 발생 <br>- Thread safety하지 않음 <br>- Callback이나 프로미스 등의 매커니즘을 사용하여 비동기 결과를 처리 |
| 블로킹        | - 요청한 작업(예: 데이터 읽기, 쓰기)이 **완료될 때까지 호출한 함수가 제어권을 반환하지 않음** <br>- 즉 특정한 작업이 완료될 때까지 현재 스레드의 실행을 중단                                                                                                                                                                                                                   |
| 논블로킹      | - 요청한 작업을 시작하고 바로 **제어권을 반환**. <br>- 특정 작업 요청 시 해당 요청이 즉시 처리되거나 거절될 수 있으며 요청 작업의 완료를 기다리지 않고 즉시 다음 명령어로 넘어갈 수 있음                                                                                                                                                                                       |

> 동기와 블로킹: 둘 다 작업의 완료를 기다린다는 공통점. 하지만, 동기는 '작업 순서 및 완료에 대한 기대'에 초점을 맞춘 반면, 블로킹은 '작업 요청 시 제어권의 반환 여부'에 초점.

> 비동기와 논블로킹: 작업의 완료를 기다리지 않는다는 공통점. 비동기는 '여러 작업을 동시에 처리하는 방식'에 초점을 두고, 논블로킹은 '함수 호출이 즉시 반환되어, 다음 코드 라인으로 넘어갈 수 있음'에 초점

---

### 멀티 스레드 프로그래밍

- 하나의 프로세스 내에서 여러 스레드를 생성하여 자원 사용의 중복을 최소화하는 기법
- 멀티 프로세스 대비 메모리 사용량이 적고, 스레드 간 통신이 용이. 또한 스레드 간 컨텍스트 스위칭이 효율적
- 하지만, 한 스레드의 오류가 다른 스레드에 영향을 미칠 수 있고, 데드락과 경쟁상태같은 동시성 이슈에 주의해야 한다
  - 교착 상태 (데드락): 서로의 잠금을 포기하기를 기다리는 상태
  - 경쟁 상태: 2개 이상의 프로세스나 스레드가 동시에 공유자원을 읽거나 쓸 때 발생하는 상태

### Thread safety

- 여러 스레드가 동시에 같은 객체에 접근해도 데이터의 일관성을 유지하는 것
- 인스턴스 변수의 사용을 지양해야 한다

### 프로세스 동기화

- 다중 프로세스 환경에서 하나의 자원에 대한 동시 접근을 제어하여 데이터의 일관성을 보장하는 방법
- 프로세스 동기화를 하지 않으면 데이터의 일관성이 깨질 수 있다

### 교착상태(Dead lock)과 기아상태의 해결 방법

- 교착상태 : 서로 다른 프로세스가 서로 점유하고 있는 자원의 반납을 대기하고 있는 상태 -> 예방, 알고리즘 수정
- 기아 상태: 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때 특정 프로세스가 영원히 자원 할당이 되지 않는 경우 -> 우선 순위를 변경해주어야 한다

### 가상 메모리

- 프로세스가 실제 메모리 크기와 상관없이 메모리를 이용할 수 있도록 지원하는 기술
- 실제 메모리 (RAM)과 보조 기억 장치의 swap 영역으로 구성

### 캐시

- 프로세스가 매번 메인 메모리에 접근해 데이터를 받아오면 시간이 오래 걸리기 때문에, 캐시에 자주 사용하는 데이터를 담아두어 처리 속도를 높인다
- 레지스터 보다는 느리지만 여전히 빠른 휘발성 메모리. 자주 사용되는 데이터는 빠른 메모리에 저장되어 빠르게 접근, 처리 가능
  -> 계층 구조를 통한 비용, 자원 효율적 사용

### 캐싱이 중요한 이유, 구현 방법

- 캐싱은 데이터 또는 계산 결과를 임시 저장하여 빠른 접근을 가능하게 함으로써 성능을 향상시킴.
- 데이터베이스 쿼리, API 호출 결과 등을 캐시에 저장하여, 동일한 요청이 있을 때 빠르게 응답 가능
- Redis와 같은 인메모리 데이터 스토어를 사용하여 캐시 구현 가능

### Scale up과 Scale Out의 차이

- scale up은 시스템의 리소스(CPU, RAM)을 늘려 성능을 향상시키는 것 > 하드웨어의 한계에 도달 가능
- 스케일 아웃은 인스턴스 수를 늘려 처리 능력을 확장시키는 것 > 분산 시스템의 복잡성 증가

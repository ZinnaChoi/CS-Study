### 배열 VS 연결리스트

| 구분                 | 배열 (Array)                                                                                                                                                                                                                                          | 연결 리스트 (LinkedList)                                                                                                                                                                                                  |
| -------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 정의                 | 인덱스를 통해 빠르게 접근할 수 있는 연속적인 메모리 공간에 데이터를 저장하는 자료구조                                                                                                                                                                 | 각 요소가 데이터와 다음 요소를 가리키는 포인터로 구성되어 있어, 요소들이 메모리 상에서 연속적이지 않게 저장되는 자료구조                                                                                                  |
| 특징                 | - 고정된 저장공간(fixed-size)을 가짐.<br>- 인덱스를 통해 데이터에 빠르게 접근 가능<br>- 크기 변경이 불편.<br>- 데이터 추가나 삭제 시 다른 요소들의 이동이 필요. <br>- fixed-size 특성상 선언 시 Array의 크기를 미리 정해야 해서 메모리 낭비 발생 가능 | - 동적 크기 조정이 가능.<br>- 요소의 추가나 삭제가 용이.<br>- 임의 접근이 불가능, 특정 요소에 접근하기 위해서는 순차적인 탐색이 필요<br>- 추가적인 메모리 공간(포인터)가 필요. <br>- 포인터를 통해 논리적인 연속성을 가짐 |
| 조회 시간복잡도      | O(1)                                                                                                                                                                                                                                                  | O(N)                                                                                                                                                                                                                      |
| 추가/삭제 시간복잡도 | O(N)                                                                                                                                                                                                                                                  | O(1)                                                                                                                                                                                                                      |

---

### 배열 VS 다이나믹 배열

| 특성             | 일반 배열                           | 다이나믹 배열 (Dynamic Array)                |
| ---------------- | ----------------------------------- | -------------------------------------------- |
| 크기 고정        | ✅ 고정됨                           | ❌ 고정되지 않음                             |
| 데이터 추가      | 초과 데이터 추가 불가능             | 초과 데이터 추가 가능                        |
| 사이즈 조절 방식 | 해당 없음                           | Resize 가능 (일반적으로 Doubling 방식 사용)  |
| 메모리 효율성    | 높음 (불필요한 메모리 할당 없음)    | 낮음 (resize 과정에서 추가 메모리 할당 필요) |
| 용도             | 크기 변동이 없는 데이터 저장에 적합 | 크기 변동이 잦은 데이터 저장에 적합          |

---

### 해시 테이블

| 구분                      | 설명                                                                                                                                                 |
| ------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| 정의                      | 키에 대한 해시 함수를 적용하여, 해시 값을 얻고 이를 인덱스로 사용하여 데이터를 배열에 저장하는 자료구조.                                             |
| 특징                      | - 빠른 데이터 검색, 삽입, 삭제가 가능.<br>- 해시 충돌을 해결하기 위한 기법이 필요(예: 체이닝, 오픈 어드레싱).<br>- 해시 함수의 선택이 성능에 큰 영향 |
| 저장,삭제,검색시간 복잡도 | - 평균: O(1) <br>- 최악: O(N)                                                                                                                        |

---

#### 해시 충돌 해결

> 해시 충돌: 두 개 이상의 키가 같은 해시 값을 가지는 경우 충돌이 발생할 수 있어, 이를 관리하기 위한 추가 구조 필요

| 기법          | 설명                                                                                     |
| ------------- | ---------------------------------------------------------------------------------------- |
| 체이닝        | - 해시 충돌 시 연결 리스트에 할당하고, 충돌 시 연결 리스트를 탐색                        |
| 오픈 어드레싱 | - 개방 주소법. <br> - 충돌 시 다른 버켓에 데이터를 삽입. 선형 탐색, 제곱 탐색, 이중 해싱 |

---

### HashMap

| -           | 설명                                                                                                     |
| ----------- | -------------------------------------------------------------------------------------------------------- |
| 정의        | 키-값을 저장하는 자료 구조로, 각 키는 해시 함수를 통해 고유한 인덱스로 변환되어, 해당 인덱스에 값이 저장 |
| 구현        | 해시 테이블을 사용하여 구현된 Map 인터페이스의 구현체                                                    |
| 시간 복잡도 | 삽입, 삭제, 검색: 평균 O(1)                                                                              |
| 키 순서     | 키의 순서 예측 불가                                                                                      |
| 특징        | - 키에 대한 해시 함수를 사용하여 값 저장. 검색 속도가 매우 빠름<br>- `null` 값을 키와 값으로 사용 가능   |

---

### TreeSet

| -           | 설명                                                                           |
| ----------- | ------------------------------------------------------------------------------ |
| 구현        | 레드-블랙 트리 기반의 Set 인터페이스 구현체                                    |
| 시간 복잡도 | 삽입, 삭제, 검색: O(log N)                                                     |
| 정렬        | 모든 요소들은 기본 오름차순 또는 Comparator에 의해 정렬됨                      |
| 특징        | - 중복 제거 & 자동 정렬<br>- `Collections.reverseOrder()`로 내림차순 정렬 가능 |

---

### 스택 VS 큐

| 구분 | 스택                                                                                       | 큐                                                                                                     |
| ---- | ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------ |
| 정의 | LIFO(Last In First Out) 원칙에 따라, 가장 마지막에 삽입된 요소가 가장 먼저 나오는 자료구조 | FIFO(First In First Out) 원칙에 따라, 가장 처음 삽입된 요소가 가장 먼저 나오는 자료구조                |
| 특징 | - 후입선출 구조.<br>- 깊이 우선 탐색(DFS)에 사용.<br>- 함수 호출, 괄호 검사 등에 활용.     | - 선입선출 구조.<br>- 너비 우선 탐색(BFS)에 사용.<br>- 프린터의 인쇄 대기열, 메시지 처리 큐 등에 활용. |

---

### 이진 탐색 트리 (BST)

| 구분 | 설명                                                                                                                                                   |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 정의 | 각 노드가 최대 두 개의 자식 노드를 가지며, 왼쪽 자식 노드는 부모 노드보다 작고, 오른쪽 자식 노드는 부모 노드보다 큰 값을 가지는 특성을 가진 트리 구조. |
| 특징 | - 중위 순회를 통해 정렬된 순서로 데이터를 탐색.<br>- 평균 검색,저장, 삭제 시간은 O(logN).<br>- 불균형 트리가 될 경우 검색 효율이 저하.(O(N))           |

---

### 이진 검색 트리 VS AVL 트리

| 구분      | 이진 검색 트리(BST)                                                           | AVL 트리                                                                              |
| --------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| 정의      | 모든 노드가 왼쪽 자식 < 노드 < 오른쪽 자식의 순서를 갖는 이진 트리            | 균형을 유지하는 이진 검색 트리로, 어떤 노드에서도 두 자식의 높이 차이가 1을 넘지 않음 |
| 특징      | - 평균적으로 O(log n)의 검색, 삽입, 삭제 시간 복잡도<br>- 불균형 시 성능 저하 | - 균형 상태 유지로 O(log n)의 검색, 삽입, 삭제 시간 복잡도 보장                       |
| 사용 사례 | - 검색에 최적화된 목록 관리                                                   | - 검색, 삽입, 삭제가 빈번한 경우 성능 보장이 필요할 때                                |

---

### 트리 VS 그래프

| 구분 | 트리                                                                                                                   | 그래프                                                                                                                                     |
| ---- | ---------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| 정의 | 계층적인 자료구조로, 사이클이 없으며 한 방향으로만 연결된 노드들의 집합                                                | 노드와 그 노드를 연결하는 에지로 구성되며, 사이클이 존재할 수 있는 네트워크 구조의 자료구조                                                |
| 특징 | - 부모-자식 관계의 노드로 구성.<br>- 루트 노드에서 출발하여 리프 노드로 끝나는 단방향 구조.<br>- 계층적 데이터 모델링. | - 에지로 연결된 임의의 복잡한 네트워크 구조를 표현.<br>- 사이클이 가능, 양방향으로 탐색<br>- 소셜 네트워크, 지도, 네트워크 구조 등에 사용. |

---

### 힙

| -           | 설명                                                                       |
| ----------- | -------------------------------------------------------------------------- |
| 구현        | 완전 이진 트리 기반의 자료구조                                             |
| 시간 복잡도 | 삽입, 삭제: O(log N)                                                       |
| 특징        | - 최댓값 또는 최솟값을 빠르게 찾기 위해 설계<br>- 최대 힙과 최소 힙이 있음 |
| 용도        | - 우선순위 큐 구현<br>- 힙 정렬, 그래프 알고리즘에 사용                    |

---

### deque (double ended queue)

> 양쪽에서 enqueue와 dequeue가 가능한 queue

---

### 우선순위 큐(Priority Queue)

| -                | 설명                                                                                                       |
| ---------------- | ---------------------------------------------------------------------------------------------------------- |
| 구현             | 힙(주로 최소 힙)을 사용하여 구현된 추상 자료형. 완전이진트리 구조                                          |
| 시간 복잡도      | 삽입, 삭제: O(log N)                                                                                       |
| 특징             | - 각 요소가 우선순위와 함께 저장됨<br>- 우선 순위가 높은 요소가 먼저 제거됨                                |
| 사용자 정의 정렬 | - `Comparator`를 사용하여 우선순위 정의 가능<br>- `Comparator.reverseOrder()`로 큰 값에 우선순위 부여 가능 |

> 비교: queue의 삽입, 삭제 시간 복잡도는 O(1)

---

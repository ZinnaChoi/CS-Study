# 인덱싱을 하는 이유

## 검색 속도 향상의 필요성
- 대규모 테이블에서 특정 데이터를 찾기 위해 전체 테이블을 스캔하는 것은 비효율적
- 인덱스는 데이터의 위치 정보를 빠르게 찾을 수 있는 별도의 자료구조를 제공

## B-tree와 B+ tree 구조

### B-tree (균형 잡힌 트리)
- **균형성**: 모든 리프 노드가 같은 레벨에 위치하여 일정한 검색 시간 보장
- **차수(order)**: 각 노드가 가질 수 있는 최대 자식 노드 수
- **정렬된 구조**: 왼쪽 서브트리 < 현재 노드 < 오른쪽 서브트리

```
B-tree 예시 (차수 3)
        [20, 50]
       /   |    \
   [10,15] [30,40] [60,70]
```

### B+ tree (B-tree의 개선된 형태)
- **리프 노드에만 실제 데이터 저장**: 내부 노드는 인덱스 키만 보관
- **리프 노드 연결**: 순차적 접근을 위해 리프 노드들이 연결 리스트로 구성
- **높은 팬아웃**: 내부 노드의 크기가 작아져 더 많은 키를 저장 가능

```
B+ tree 예시 (차수 3)
         [20, 50]
        /    |    \
    [20]    [50]   [70]
   /        |       \
[10,15] → [20,30,40] → [50,60,70] → null
(리프 노드들이 연결되어 있음)
```

## 인덱스 적용 시점
- **대규모 테이블**: 수백만 건 이상의 데이터
- **읽기 중심 작업**: 조회가 삽입/수정/삭제보다 빈번한 경우
- **범위 검색**: WHERE, ORDER BY, GROUP BY 절이 자주 사용되는 컬럼

## 빠른 판단이 가능한 이유
- **균형 잡힌 구조**: O(log n) 시간 복잡도로 검색
- **테이블에 없는 정보**: 인덱스를 통해 존재하지 않는 데이터임을 빠르게 판단
- **부분 매치**: B+ tree의 정렬된 특성으로 범위 검색 최적화

## 인덱스의 단점

### 메모리 오버헤드
- **추가 저장공간**: 인덱스 구조를 위한 별도 메모리 필요
- **메모리 사용량 증가**: 테이블 크기의 10-15% 추가 공간 소모

### 성능 저하 요소
- **삽입/수정/삭제 시 오버헤드**: 데이터 변경 시 인덱스도 함께 업데이트 필요
- **B+ tree 재구성**: 노드 분할이나 병합으로 인한 추가 연산
- **다중 인덱스**: 여러 인덱스 유지 시 DML 성능 저하



# 트랜젝션

## 트랜젝션의 정의
하나 이상의 데이터베이스 연산을 논리적으로 묶어서 전부 성공하거나 전부 실패하는 작업 단위

## ACID 특성

### Atomicity (원자성)
- 트랜젝션 내 모든 연산이 전부 성공하거나 전부 실패
- 부분적인 성공은 허용하지 않음
- 실패 시 rollback으로 이전 상태로 복구

### Consistency (일관성)
- 트랜젝션 실행 전후에 데이터베이스가 일관된 상태 유지
- 무결성 제약조건, 비즈니스 규칙 위반 방지
- 예: 계좌 이체 시 총 금액 불변

### Isolation (격리성)
- 동시 실행되는 트랜젝션들이 서로 영향을 주지 않음
- 각 트랜젝션이 독립적으로 실행되는 것처럼 보장
- 동시성 제어를 통해 구현

### Durability (지속성)
- 커밋된 트랜젝션의 결과는 영구적으로 저장
- 시스템 장애가 발생해도 데이터 손실 없음
- 로그, 백업 등으로 보장

## TPS (Transaction Per Second)
- 초당 처리 가능한 트랜젝션 수
- 데이터베이스 성능 측정 지표
- 높은 TPS = 높은 동시성 처리 능력

## 동시성 이슈

### 발생 가능한 문제들
- **Dirty Read**: 커밋되지 않은 데이터 읽기
- **Non-repeatable Read**: 같은 쿼리의 결과가 달라짐
- **Phantom Read**: 범위 검색 시 새로운 행이 나타남

## Isolation Level

### READ UNCOMMITTED
- 가장 낮은 격리 수준
- Dirty Read 발생 가능
- 성능은 최고, 일관성은 최저

### READ COMMITTED
- 커밋된 데이터만 읽기 허용
- Dirty Read 방지
- 대부분의 DBMS 기본 설정

### REPEATABLE READ
- 같은 트랜젝션 내에서 동일한 읽기 결과 보장
- Non-repeatable Read 방지
- MySQL InnoDB 기본 설정

### SERIALIZABLE
- 가장 높은 격리 수준
- 모든 동시성 문제 방지
- 성능 저하 가능성

## 락(Lock) 메커니즘

### 낙관적 락(Optimistic Lock)
- **전제**: 충돌이 거의 발생하지 않을 것으로 가정
- **방식**: 버전 번호나 타임스탬프 사용
- **장점**: 성능 우수, 데드락 없음
- **단점**: 충돌 시 재시도 필요
```sql
UPDATE products
SET name = '새상품명', version = version + 1
WHERE id = 1 AND version = 10;
```

### 비관적 락(Pessimistic Lock)
- **전제**: 충돌이 자주 발생할 것으로 가정
- **방식**: 데이터 접근 전에 미리 락 획득
- **장점**: 데이터 일관성 확실히 보장
- **단점**: 성능 저하, 데드락 가능성
```sql
SELECT * FROM products WHERE id = 1 FOR UPDATE;
```


# DB Connection Pool

## Connection Pool이 필요한 이유

### 데이터베이스 연결 비용
- **연결 생성 오버헤드**: TCP 핸드셰이크, 인증, 세션 초기화
- **시간 소모**: 새 연결마다 수백 밀리초 소요
- **리소스 낭비**: 연결/해제 반복으로 인한 CPU, 메모리 낭비

### Connection Pool의 장점
- **성능 향상**: 미리 생성된 연결 재사용으로 응답 시간 단축
- **리소스 관리**: 연결 수 제한으로 데이터베이스 부하 조절
- **안정성**: 연결 실패 시 대체 연결 제공
- **확장성**: 동시 사용자 증가에 효율적 대응

## 연결 대기 지연이 발생하는 이유

### Pool Size 부족
```
Pool Size: 10개
동시 요청: 15개
→ 5개 요청이 연결 반납 대기
```

### 장시간 연결 점유
- **긴 쿼리 실행**: 복잡한 조인, 대용량 데이터 처리
- **트랜젝션 지연**: 사용자 입력 대기, 외부 API 호출
- **연결 누수**: 개발자 실수로 연결 미반납

### 데이터베이스 성능 이슈
- **슬로우 쿼리**: 인덱스 부재, 비효율적 쿼리
- **락 대기**: 트랜젝션 간 충돌로 인한 대기
- **리소스 부족**: CPU, 메모리, 디스크 I/O 병목

## Connection Pool 최적화 방안

### Pool 크기 조절
```
적정 Pool Size = (Core 수 × 2) + HDD 수
예: 4 Core + 1 HDD = 9개 연결
```

### 연결 검증 및 정리
- **Validation Query**: 연결 유효성 주기적 확인
- **Max Idle Time**: 유휴 연결 자동 해제
- **Connection Timeout**: 연결 대기 시간 제한

### 모니터링 지표
- **Active Connections**: 현재 사용 중인 연결 수
- **Pool Utilization**: 전체 대비 사용률
- **Wait Time**: 연결 대기 시간
- **Connection Leaks**: 반납되지 않은 연결 수
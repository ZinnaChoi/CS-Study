# 자료구조의 시간 복잡도 총정리

> 자료구조에 대한 시간 복잡도를 어느정도 외우고 있어야, 비지니스 로직을 코드로 구현해야 할 때 적적한 자료구조 사용 가능

### 예시

- Q: 어떠한 요소의 모음에서 n 번째 요소를 계속해서 접근(참조)해야 하는 로직이 있다면 이와 걸맞는 자료구조?
- A: 배열. 연결 리스트를 쓰게 된다면 접근(참조)에 매번 O(n)의 시간 복잡도가 드는 반면, 배열은 O(1)의 시간복잡도가 걸리기 때문

### 자료구조의 시간복잡도

> 해시 테이블을 제외하고는 평균 시간복잡도 = 최악 시간복잡도

#### 배열(Vector)

- 참조: O(1)
- 탐색: O(n)
- 맨끝, 맨 앞에 삽입/삭제: O(1)
- 중간에 삽입/삭제: O(n)

#### 연결리스트(doubly linked List)

- 참조: O(n)
- 탐색: O(n)
- 삽입/삭제: O(1)

#### 스택(stack)

- n 번째 참조: O(n)
- 가장 앞 부분 참조: O(1)
- 탐색: O(n)
- 삽입/삭제(n번째 제외): O(1)

#### 큐(queue)

- n번째 참조: O(n)
- 가장 앞부분 참조: O(n)
- 탐색: O(n)
- 삽입/삭제(n번째 제외): O(1)

#### 맵(map)

- 참조: O(logn)
- 탐색: O(logn)
- 삽입,삭제: O(logn)

#### 셋(set)

- 참조: O(logn)
- 탐색: O(logn)
- 삽입,삭제: O(logn)

#### 해시 테이블(hash table)

##### 평균 시간복잡도

- 참조: O(1)
- 탐색: O(1)
- 삽입, 삭제: O(1)

#### 최악 시간복잡도 -> 해시 충돌

- 참조: O(n)
- 탐색: O(n)
- 삽입,삭제: O(n)

#### 힙(heap)

- 참조(최대 또는 최댓값을 참조): O(1)
- 탐색: O(n)
- 삽입,삭제: O(logn)

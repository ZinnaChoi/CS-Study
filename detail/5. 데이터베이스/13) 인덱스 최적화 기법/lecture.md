# 인덱스 최적화 기법

> 1. 인덱스는 비용이다

- 인덱스는 2번 탐색하도록 강요한다
- 인덱스 리스트, 그 다음 컬렉션 순으로 탐색하기 때문이며 그와 관련한 읽기 비용이 들게 된다
- 또한 컬렉션이 수정되었을 때, 인덱스도 같이 수정되어야 한다
  - 책의 본문이 수정되었을 때 목차도 수정되어야 하는 것과 비슷
- B-Tree의 높이를 균형있게 조절하는 비용도 필요
- 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 필요

- 따라서 쿼리에 있는 필드(컬럼)에 인덱스를 무작정 다 설정하는 것은 답이 아님
- 컬렉션에서 가져와야 하는 양이 많을수록, 인덱스를 사용하는 것이 비효울적

> 2. 항상 테스팅하라

- 인덱스 최적화 기법은 서비스의 특징에 따라 달라진다. 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문
- 따라서 항상 테스팅하는 것이 중요.
- explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간ㅇ르 최소화해야 한다

- ex) MySQL의 인덱스 테스트 코드

```sql
EXPLAIN
SELECT * FROM t1
JOIN t2 ON t1.c1 = t2.c1
```

> 3. 복합 인덱스는 같음 > 정렬 > 다중값 > 카디널리티 순

- 보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다

```
[인덱스 생성 순서]

1. 같음: 어떠한 값과 같음을 비교하는 == 이나 equal이라는 쿼리가 있다면 제일 먼저 인덱스로 설정
2. 정렬: 정렬에 사용되는 필드라면 그 다음 인덱스로 설정
3. 다중값을 출력해야 한느 필드, 즉 쿼리 자체가 > 이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰이는 필드라면 나중에 인덱스를 설정
4. 카디널리티 = 유니크한 값의 정도
카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 한다
- ex) age와 email 중 email이 카디널리티가 더 높음 > email 필드에 대한 인덱스를 먼저 생성해야 한다
```
